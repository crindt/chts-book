---
documentation: '`r if(exists("documentation")){documentation}else{documentation<-"true";documentation}`'
title: '`r paste("CHTS 2011/2012 Summary Tables",if(exists("documentation")){"---Documentation"}else{""})`' 
author: "Craig Rindt"
date: '`r file.mtime(knitr::current_input())`'
geometry: margin=1in
fontfamily: inconsolata
documentclass: '`r if (exists("documentation")) {"report"}else{"article"}`'
output:
  pdf_document:
    keep_tex: yes
    toc: yes
    template: custom.latex
    number_sections: yes
    pandoc_args: [
      "--chapters"
    ]
  html_document:
    toc: yes
---


```{r rt-setup-0,echo=FALSE,cache=FALSE}
if ( !exists("rd") ) { rd <- gsub("(.*?chts-book).*","\\1",getwd()) }
source(paste(rd,'R/setup-hooks.R',sep="/"))
null<-lapply(
  c("chts_hh","chts_per","chts_pla","chts_act","chts_veh","chts_lt","chts_lu_lt"),
  function(v) { if (exists(v)) { rm(v) } }
)
```

\ifmydocumentation

```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('#','Using R to Generate Summary Tables')
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','Setup')
```

```{r rt-recreating-2001-tables-setup,cache=FALSE,echo=TRUE}
# Set the working directory so we can access libraries
write(paste("Setting working directory to",rd,"\n"),stderr())
setwd(rd)

# Load common setup
suppressMessages(require(knitr))    # knitr creates documentation from this file
suppressMessages(require(pander))   # pander is a package for generating tables
suppressMessages(require(testit))   # testit is a testing library
suppressMessages(require(dplyr))    # data manipulation
suppressMessages(require(tidyr))    # ...and data wrangling
suppressMessages(library(logging))
suppressMessages(library(lazyeval)) # for interp
suppressMessages(require(Hmisc))    # wtd.table

# Load CHTS data
library(chts2011) 
library(chts2011pvt)
library(chts2011wgt)

# read in the FIPS county table for pretty printing
fipsctyca <- read.csv(paste(rd,"data/fips-county.csv",sep="/"),
                      header=TRUE,
                      stringsAsFactors=FALSE) %>%
  filter(state=="CA") %>% 
  mutate(County=gsub(" County$","",county_name))


# set some knitr defaults for producing documentation outputs
opts_chunk$set(
  eval=TRUE,echo=TRUE,messages=FALSE,
  warnings=TRUE,errors=TRUE,cache=TRUE,dpi=300,
  size='tiny',collapse=TRUE,my.relfontsize=-1,
  fig.height=4)
options("scipen"=100,"digits"=4)          # default precision for floats
panderOptions('big.mark',',')             # use commas in big numbers
panderOptions('table.split.table',Inf)    # don't wrap tables
panderOptions('table.split.cells',Inf)    # don't wrap cells
panderOptions('keep.trailing.zeros',FALSE)
panderOptions('round',1)
```

```{r rt-general-definitions}
single.family <- c(1)   # RESTY values: single family homes
multi.family  <- c(2:6) # RESTY values
```

```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','Weighting Calculations')
```

Weights used in the calculations of the following tables were generated
separately.

Here we load in various weights used in the calculations below, including
weekday weights and county weights (and county weekday weights).

```{r rt-load-weights}
library(chts2011wgt)
```

```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','Table A: Key 2011-2012 Travel Survey Data for California')
```


Table A contains a range of information about households.  In R, we'll construct
this table as a list with named rows, so we begin by creating an empty list.

```{r rt-table-a-0}
adat <- list()
```

Now, we'll describe how to create each element of the table.  First, the number
of vehicles available is simply the weighted sum of the household vehicles
available in the sample.

```{r rt-table-a-1}
# weighted sum of vehicles available
adat[['Vehicles Available']] <- round(sum(chts_hh$HHVEH*chts_hh$EXPHHWGT),0)
```

The next element is vehicles in use on the average weekday.  This requires
weights based upon the subsample of households whose data was collected on a
weekday.  We loaded these weights earlier.  **FIXME: Technically, this should
omit holidays, which is a step we leave for later improvement.**

To compute the vehicles in use, we filter all `place` records for those in which
`VEHNO` is between 1 and 8.  This indicates that a household vehicle was used
for this trip.  We then attach the household statewide weekday weights, filter
for weekday samples only, group by `SAMPN` and `VEHNO` to get a single record
for each vehicle in use, then compute the weighted sum.

```{r rt-table-a-2}
# Identify vehicles in use
hhvehinuse <- chts_pla %>%
  filter(VEHNO > 0 & VEHNO < 9) %>%            # select records using HH veh
  left_join(chts_hh.wgt.wd,by=c('SAMPN')) %>%  # attach weekday weights
  filter(WD==1) %>%                            # select only weekdays
  group_by(SAMPN,VEHNO,NEXPHHWDWGT) %>%        # get a single record for each veh
  summarise(cnt=n())                           # # of trips/veh (not used)

# Total vehicles in use is the weighted sum of vehicles in use
totvehinuse <- sum(hhvehinuse$NEXPHHWDWGT)

# The table puts the % of vehicles in use in the label, we compute that here
hhvehinuselabel <- paste('Vehicles In Use on Average Weekday (',
            round(100*totvehinuse/adat[['Vehicles Available']],2),
            '%)',sep="")

# Add the solution to the list
adat[[hhvehinuselabel]]  <- round(totvehinuse,0)
```

The total number of household workers is simply the weighted sum of the `HHEMP`
variable, which reports the number of full and/or part-time workers in the
household.  We are using statewide weights here.

```{r rt-table-a-3}
adat[['Full-Time/Part-Time Employees']] <-
  round(sum(chts_hh$HHEMP*chts_hh$EXPHHWGT),0)
```

Licensed drivers is computed similarly from the `HHLIC` variable.

```{r rt-table-a-4}
adat[['Licensed Drivers']] <-
  round(sum(chts_hh$HHLIC*chts_hh$EXPHHWGT),0)
```

Occupied housing units is simply the weighted sum of all households.

```{r rt-table-a-5}
# Occupied Housing Units (Household) 
tothh <- sum(chts_hh$EXPHHWGT)
adat[['Occupied Housing Units (Household)']] <- round(tothh,0)
  
```

Following the definitions from 2001, we compute single housing units as the 
weighted sum of all households defined with `RESTY==1`, where `RESTY` is 
defined as follows:

```{r rt-resty-list,echo=FALSE,results='asis'}
pandoc.list(strsplit((chts_md %>% filter(VAR.NAME=='RESTY'))[1,'VALUES'],'\n')[[1]])
```

```{r rt-table-a-5-1}
# Single Housing Units 
shu <- chts_hh %>% filter(RESTY %in% single.family)

adat[['Single Housing Units']] <- round(100*sum(shu$EXPHHWGT)/tothh,1)
```

Multiple housing units is defined as duplexes, mobile homes, and multi-unit
buildings.

```{r rt-table-a-5-2}
# Multiple Housing Units
mhu <- chts_hh %>% filter(RESTY %in% multi.family)

adat[['Multiple Housing Units']] <- 
  round(100*sum(mhu$EXPHHWGT)/tothh,1)
```

Other housing units are boats/RVs, other, or refused.

```{r rt-table-a-5-3}
# Other Housing Units 0.6%
ohu <- chts_hh%>%filter(RESTY %in% c(7:99))

adat[['Other Housing Units']] <- round(100*sum(ohu$EXPHHWGT)/tothh,1)
```

To compute the median household income when income is defined as ordinal variable, 
we'll follow the US Census bureau's method (described 
[here (p6)](http://www.census.gov/hhes/www/p60_243sa.pdf) and 
[here](http://www.s4.brown.edu/us2010/SUC/MHHINote.htm).  The method is 
to compute the median category and then use 
[pareto interpolation](https://en.wikipedia.org/wiki/Pareto_interpolation) 
within that category range to determine the median.

```{r rt-table-a-8}
# Median Household Income

# First, compute the weighted median
suppressMessages(require(isotone)) # for weighted median function
median.category <- weighted.median(chts_hh$INCOM,chts_hh$EXPHHWGT)

# Next, get the upper and lower bound of this range, we do this by reading the
# bounds from the string definition stored in the factor label
catvals <- assign_factors(c(median.category),'hh','INCOM')  # get factor label

# Convert "$1,234 to $12,345" to c(1234,12345)
lohi <- as.integer(gsub("[$,]","",(unlist(strsplit(as.character(catvals[[1]])," to ")))))


# Determine parameters for pareto interpolation
a <- lohi[1]  # income value at the lower limit of the category containing the median
b <- lohi[2]  # income value at the upper limit of the category containing the median
Pa <- (chts_hh %>% filter(INCOM < median.category) %>% 
         summarise(n=sum(EXPHHWGT)))[1,'n']/tothh
Pb <- (chts_hh %>% filter(INCOM < (median.category+1)) %>% 
         summarise(n=sum(EXPHHWGT)))[1,'n']/tothh

# Apply pareto interpolation functions
thetaf <- function(a,b,Pa,Pb) {
  return ((log10(1-Pa)-log10(1-Pb))/(log10(b)-log10(a)))
  }
kappaf <- function(a,b,Pa,Pb) {
  theta <- thetaf(a,b,Pa,Pb)
  return (((Pb-Pa)/((1/(a^theta)) - (1/(b^theta))))^(1/theta))
  }
theta <- thetaf(a,b,Pa,Pb)
kappa <- kappaf(a,b,Pa,Pb)
hhmedian <- kappa*(2^(1/theta))

# Store the result
adat[['Median Household Income']] <- hhmedian
```

To determine the persons per household, we compute the weighted mean of
household size (`HHSIZ`) using statewide expansion weights.

```{r rt-table-a-9}
# Persons Per Household 2.8
adat[['Persons per Household']] <-
  round(wtd.mean(chts_hh$HHSIZ,weights=chts_hh$EXPHHWGT),1)
```

We take a similar approach for vehicles per household, taking the weighted mean
of the `HHVEH` variable.

```{r rt-table-a-10}
# Vehicles Per Household 1.9
adat[['Vehicles per Household']] <-
  round(wtd.mean(chts_hh$HHVEH,weights=chts_hh$EXPHHWGT),1)
```

For employees per household, we find the weighted mean of `HHEMP`.

```{r rt-table-a-11}
# Full/Part-Time Employees Per Household 1.2
adat[['Full/Part-Time Employees Per Household']] <-
  round(wtd.mean(chts_hh$HHEMP,weights=chts_hh$EXPHHWGT),1)
```

And, finally, for licensed drivers per household, we compute the weighted mean
of `HHLIC`.

```{r rt-table-a-12}
# Licensed Drivers Per Household 1.7
# NOTE: persons 16 or older
adat[['Licensed Drivers Per Household']] <-
  round(wtd.mean(chts_hh$HHLIC,weights=chts_hh$EXPHHWGT),1)
```

Now, we can compute the table.  Note that throughout this documentation, we are
using the `pander` package to generate markdown tables that can be processed by
`pandoc` to create tables in a variety of formats.  The `pandoc.table.return`
function generates the table in markdown format and returns it as a string.  We
are storing these strings so we can output all of the tables in the Appendix.

```{r rt-table-a_1} 
res <- list()
res.a.1 <- t(t(unlist(adat)))
colnames(res.a.1) <- c("Household Information") 
res.a.1.str <-
  pandoc.table.return(
    res.a.1,
    justify=c('left','right'),
    caption="TABLE A: Household Information"
  )
```

Print out the table inline.  For the remaining tables, we will print them out,
but will not echo the code that prints them as it is redundant.  We include it
here to illustrate the method.

```{r rt-table-a_1-results,results='asis'}
cat(res.a.1.str)
```

To determine household vehicle availability in categories consistent with the
2001 tables, we transform the `HHVEH` variable to be 0, 1, 2, and 3+.

```{r rt-table-a_2}
vd <- chts_hh %>% transmute(HHVEHg=ifelse(HHVEH>2,3,HHVEH),EXPHHWGT)
```

Then, we use the `wtd.table` function from the `Hmisc` package to
generate a weighted frequency table from that transformed data.

```{r rt-table-a_2b,results='asis',cache=FALSE}
# apply wtd.table, whose output needs to be converted into a dataframe that can be 
# used by pandoc.table
res.a.2 <- as.data.frame(wtd.table(vd$HHVEHg,weights=vd$EXPHHWGT)$sum.of.weights)

# Manipulate the weighted table into percents and define col and row names
colnames(res.a.2) <- c('Percent of Households')
res.a.2[,1] <- paste(
  round(100*res.a.2$`Percent of Households`/sum(res.a.2$`Percent of Households`),0),
  '%',sep='')
rownames(res.a.2) <- gsub("3 ","3+ ",paste(rownames(res.a.2),'Vehicles'))

# create the table
res.a.2.str <- pandoc.table.return(res.a.2,
             split.tables=Inf,split.cells=Inf, 
             justify=c('left','right'),
             big.mark=',',
             caption="TABLE A: Household Vehicle Availability")
```

```{r rt-res-a-cat,echo=FALSE,results='asis'}
cat(res.a.2.str)
res[["res.a"]] <- list()
res[["res.a"]]$title  <- "TABLE A: Household Vehicle Availability"
res[["res.a"]]$data.1 <- res.a.1
res[["res.a"]]$data.2 <- res.a.2
res[["res.a"]]$tabtxt <- paste(res.a.1.str,res.a.2.str,sep="\n\n\n")
```

```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','Table B: Weekday Trip Information')
```


The weekday trip information is based upon linked trips, which have
been calculated elsewhere and included as part of the `chts2011`
package in the `chts_lt` data frame.

However, as above, we need appropriate weights for weekday travel.
Recall that for Table A, we computed household weights for weekdays.
Trips are person-specific, so we need to compute *person* weights by
weekday vs weekend.  Again, this requires recomputation of weights
based upon the subsample of people whose data was collected on a
weekday.  Luckily, we have already done this as part of the
`chts2011wgt` package (loaded previously) and can access them directly
as `chts_per.wgt.wd`.  Let's read in the linked trips and join the
appropriate trips to people sampled on weekdays.

```{r rt-setup-linked-trips}

# First, create a clean version of the linked trips, omitting any
# trips that lack a mode or origin place (these are typically the
# "start" trip of a person's day
lt.clean <- chts_lt %>% filter(!is.na(ltmode) & !is.na(oplano))

lt.wd.trips <- chts_per.wgt.wd %>%           # weekday people w/weights
    filter(WD==1) %>%                               # weekday travelers
  select(SAMPN,PERNO,WD,NEXPPERWDWGT,NPERWDWGT) %>% # specific cols
  left_join(lt.clean,by=c('SAMPN','PERNO')) %>%     # join linked trips
  mutate(NEXPTCFPERWDWGT=NEXPPERWDWGT*ltTCF)        # compute TCF weights
```

Now let's compute each element of the table.  Total trips will be the
weighted sum of the linked trips (including the GPS trip correction
factor).  The first thing we need to do is clarify some definitions.
Throughout, we follow the definitions of the 2001 report as much as
possible.

First, we set up some lists of the `all.modes`, `driver.trip.modes`,
`person.trip.modes`, `vehicle.trips.modes`,
`public.transit.trip.modes`, and `public.transport.trip.modes`

```{r rt-mode-defs-setup-1}
all.modes=sort(unique(lt.clean$ltmode))

driver.trip.modes=c(5,8)

person.trip.modes=all.modes[-c(1,2,3,4)]

# only trips related to private vehicle occupancy
# see p298(312) of the 2001 summary report
vehicle.trip.modes <- c(5)  

public.transit.trip.modes <- 
  c(15,16,17,
    #18,  # don't include school bus?
    19,20,21,
    # 22,23, exclude Amtrak bus and other bus
    24,25,26,27,28
    )

public.transport.trip.modes <-
  c(public.transit.trip.modes,
    12, # greyhound == intercity bus?
    13,
    22,23 # include Amtrak bus and other bus as "intercity" bus
    )
```

Next, we create the `modetab` dataframe to store (and print) how we
define modes, along with storing the filters we'll use to select
specific modes throughout the document.

```{r rt-mode-defs-setup-2}
mode.defs <- list(
  all.modes=all.modes,
  person.trip.modes=person.trip.modes,
  driver.trip.modes=driver.trip.modes,
  vehicle.trip.modes=vehicle.trip.modes,
  public.transit.trip.modes=public.transit.trip.modes,
  public.transport.trip.modes=public.transport.trip.modes
)

# create the table holding descriptions and filters we'll apply
modetab <- data.frame(
  type=c(
    "PERSON TRIPS",
    "DRIVER TRIPS",
    "PUBLIC TRANSIT TRIPS",
    "PUBLIC TRANSPORTATION TRIPS"),
  def2001=c(
    "Include all in-vehicle driver and passenger trips including\
 public transit and rail passengers for household members five\
 years of age or older. Person trips exclude walk, bicycle,\
 airplane (commercial and private), and \"other\" mode trips. Don’t\
 Know and Refused responses are not included.",
 "Include automobile, pickup truck, RV, Sport Utility Vehicle, van,\
 truck, and Motorcycle/Moped driver trips.",
 "Include modes such as local public bus, express bus,\
 Dial-A-Ride/Paratransit, light rail/streetcar/trolley, Metro Blue\
 Line, Metro Green Line, Metro Red Line, BART, CALTRAIN, Metro Link,\
 and AMTRAK. (Note that intercity bus and commercial airplane\
 passengers are not included as public transit trips in this report.)",
 "Include modes such as local public bus, express bus,\
 Dial-A-Ride/Paratransit, light rail/streetcar/trolley, Metro Blue\
 Line, Metro Green Line, Metro Red Line, BART, CALTRAIN, Metro Link,\
 AMTRAK, intercity bus and commercial airplane passengers."),
 notes=c(
   "",
   "",
   "We have included school bus in this definition.  We interpreted\
 intercity bus to be greyhound and Amtrak bus, so *excluded* here",
    "We interpreted intercity bus to be greyhound and Amtrak bus, so\
 *included* here"
 ),
 modefilt=c(
   unlist(
     lapply(c(
       "ltmode %in% person.trip.modes",
       "ltmode %in% driver.trip.modes",
       "ltmode %in% public.transit.trip.modes",
       "ltmode %in% public.transport.trip.modes"
     ),function(f) {
       return (paste(interp(f,.values=mode.defs),sep="",collapse=""));
     }))),
 otherfilt=c(
   "AGE > 4",
   "","",""
 ),
 stringsAsFactors=FALSE)

# format the modtab for printing in the documentation
res.b.0 <- modetab %>% transmute(
  type = type,
  "2001 Definition"=def2001,
  Modes=modefilt,                
  Notes=paste(notes,otherfilt,sep=". ")
  )
res.b.0$Modes <- lapply(res.b.0$Modes,function(f) { 
  return (
    paste(
      assign_factors(
        (data.frame(ltmode=all.modes) %>% filter_(f))$ltmode,
        'place','MODE',verbose=FALSE),
      sep="; ")) 
  })
b.0.str <- pandoc.table.return(
  res.b.0,
  style='multiline',
  split.tables=Inf,
  split.cells=Inf,
  justify=c('left','left','left','left')
  )
```

```{r rt-results-b-0,results='asis',cache=FALSE,echo=FALSE}
cat(b.0.str)
```

Next, we create the actual filters from the definitions in `modetab`.
We're using some advanced methods from the lazyeval package to convert
strings into code.  The important thing to understand is that the
various filters (e.g., `person.trips.filter`) can be applied to the
CHTS dataframes using `dplyr`'s `filter` command to select relevant
subsets of data for analysis.

```{r rt-table-b-setup,echo=FALSE}
suppressMessages(require(lazyeval))
modetab <- modetab %>% mutate(
  filt=gsub(" & $","",paste(modefilt,otherfilt,sep=" & "))
  )
person.trips.filter <- interp(
  (modetab %>% filter(type=='PERSON TRIPS'))[1,'filt'],
  .values=mode.defs)
driver.trips.filter <- interp(
  (modetab %>% filter(type=='DRIVER TRIPS'))[1,'filt'],
  .values=mode.defs)
public.transit.trips.filter <- interp(
  (modetab %>% filter(type=='PUBLIC TRANSIT TRIPS'))[1,'filt'],
  .values=mode.defs)
public.transport.trips.filter <- interp(
  (modetab %>% filter(type=='PUBLIC TRANSPORT TRIPS'))[1,'filt'],
  .values=mode.defs)
```

Moving on to elements of the table.  We begin with the total (linked)
trips, which is simply the weighted sum of linked trips.  (NOTE:
`na.rm=TRUE` is used throughout as there is at least one linked trip
record with an `NA` value for TCF.)

```{r rt-table-b-1}
bdat=list()     # create the list for storing table B data

# Total Trips
bdat[['Total Trips']] <- 
  round(sum(lt.wd.trips$NEXPTCFPERWDWGT,na.rm=TRUE),0)
```

Person trips are computed by as the sum of linked trips that match the
`person.trips.filter` we defined above.  Because person trips are
limited to those trips involving people over four years of age, we
need to join the `AGE` column from the `chts_per` table.  Note that
the `filter_` variant of the `filter` function allows us to specify
the filter formula as a string from the table above (instead of bare
code).

```{r rt-table-b-2}
# Person Trips are all trips except walk,bike,wheelchair, or
# non-motorized involving persons over age four
lt.per.wd <- lt.wd.trips %>% 
  left_join(chts_per %>% select(SAMPN,PERNO,AGE),by=c('SAMPN','PERNO')) %>%
  filter_(person.trips.filter)

# simply the weighted sum
bdat[['Person Trips']] <- round(
  sum(
    lt.per.wd$NEXPTCFPERWDWGT,na.rm=TRUE
    ),
  0)
```

Driver trips are computed similarly, except we don't need to worry
about the AGE filter, which is redundant in this case.

```{r rt-table-b-3}
# Driver Trips** 68,053,113
# Vehicle driver or motorcycle driver
lt.driver.wd <- lt.wd.trips %>% filter_(driver.trips.filter)

# Weighted sum
bdat[['Driver Trips']] <- 
  round(
    sum(lt.driver.wd$NEXPTCFPERWDWGT,na.rm=TRUE),
    0)
```

To compute weekday trips per household, we'll simply divide the total
trips computed above by the total number of households.

```{r rt-table-b-4}
# Total Trips Per Household

# Total households
tot.hh.wd <- (
  chts_hh.wgt.wd %>%
    filter(WD==1) %>%
    summarise(n=sum(NEXPHHWDWGT))
)[1,'n']

# total trips computed above divided by total households...
ttph <- bdat[['Total Trips']] / tot.hh.wd

# Compute and store the result
bdat[['Total Trips Per Household']] <- round(ttph,1)
```

Person trips per household is computed the same way using person trips
instead of household trips.  We simply reuse the total number of
households.

```{r rt-table-b-5}
# Person Trips Per Household 7.9
bdat[['Person Trips Per Household']] <-
  round(bdat[['Person Trips']]/tot.hh.wd,1)
```

Person trips per person five years of age or older is again computed
by reusing the total weekday person trips and dividing by the total
number of persons five years of age or older.

```{r rt-table-b-6}
# Person Trips Per Person Five Years of Age or Older

# Total persons 5 years or older (on weekdays)
tot.per.wd.5 <- 
  sum(
  (chts_per %>%
     left_join(chts_per.wgt.wd,by=c('SAMPN','PERNO')) %>%
     filter(WD==1 & AGE > 4)
  )$NEXPPERWDWGT,
  na.rm=TRUE)

# Compute and store the result
bdat[['Person Trips Per Person Five Years of Age or Older***']] <-
  round(bdat[['Person Trips']]/tot.per.wd.5,1)
```

Driver trips per household is total driver trips divided by total
households.  We reuse early calculations to get the result.

```{r rt-table-b-7}
# Driver Trips Per Household
bdat[['Driver Trips Per Household']] <-
  round(bdat[['Driver Trips']]/tot.hh.wd,1)
```

Driver trips per vehicle available is total driver trips divided by
total vehicles available. We reuse early calculations to get the
result.

```{r rt-table-b-8}
# Driver Trips Per Vehicle Available
bdat[['Driver Trips Per Vehicle Available']] <-
  round(bdat[['Driver Trips']]/adat[['Vehicles Available']],1)
```

Drive trips per vehicle in use on travel day is total driver trips
divided by vehicles in use on the travel day.  We reuse early
calculations to get the result.


```{r rt-table-b-9}
# Driver Trips Per Vehicle In Use on Travel Day 4.8
bdat[['Driver Trips Per Vehicle In Use on Travel Day']] <-
  round(bdat[['Driver Trips']]/adat[[hhvehinuselabel]],2)
```

Vehicle occupancy is a little tricky with linked trips as it varies
per leg of trip.  The linked trip table includes the maximum number of
travelers on any leg (`MAXTR`) and the minimum number of travelers
(`MINTR`).  For our purposes here, we'll assume we want the average
*maximum* number of travelers. 

First, to make our table legible, we'll add a blank line to act as a
heading for the vehicle occupancy section (we'll replace the NA with a
blank when we construct the table).

```{r rt-table-b-10}
# Vehicle Occupancy
bdat[['Vehicle Occupancy']] <- NA
```

The 2001 table listed occupancy for 24 hours and for the AM peak
(7-9am).  In both cases we define occupancy as the weighted mean of
`MAXTR`.  Here we compute the 24 hour occupancy by filtering the
weekday linked trips and then computing the weighted mean.

```{r rt-table-b-10_1}
#  All Trips (24 hours) 1.4
lt.wd.trips.veh <- lt.wd.trips %>%
  # let's filter on only "vehicle" trips (no transit)
  filter(ltmode %in% vehicle.trip.modes)
bdat[['&nbsp;&nbsp;All Trips (24 hours)']] <-
  round(
    wtd.mean(lt.wd.trips.veh$MAXTR,
             weights=lt.wd.trips.veh$NEXPTCFPERWDWGT),
    1)
```

For AM trips, we perform the same calculation as above, except we add
a filter for trips departing between 7am and 8:59am.

```{r rt-table-b-10_2}
#  All Weekday Trips (7-9 a.m.)
lt.wd.trips.am <- lt.wd.trips %>% 
  filter((DEP_HR >= 7 & DEP_HR <9)) # trips starting during AM window

lt.wd.trips.am.veh <- lt.wd.trips.am %>% 
  # let's filter on only "vehicle" trips (no transit)
  filter(ltmode %in% vehicle.trip.modes)

bdat[['&nbsp;&nbsp;All Trips (7-9am)']] <-
  round(
    wtd.mean(    
      lt.wd.trips.am.veh$MAXTR,
      weights=lt.wd.trips.am.veh$NEXPTCFPERWDWGT),
    1)
```

We're also interested in the occupancies for Home-Work vehicle trips
for both 24 hours and the AM peak.  The calulations are similar to
those above, we simply filter for trips with a TripType of `HW`.  Here
is the 24-hour calculation (we re-use data frames from above and
simply add the additional `HW` filter).

```{r rt-table-b-10_3}
#  Home-Work Trips (24 hours) 1.1
lt.wd.trips.hw.veh <-
  lt.wd.trips.veh %>%
  filter(TripType=='HW') 

bdat[['&nbsp;&nbsp;Home-Work Trips (24 hours)']] <-
  round(
    wtd.mean(lt.wd.trips.hw.veh$MAXTR,
             weights=lt.wd.trips.hw.veh$NEXPTCFPERWDWGT),
    1)
```

Here is the AM peak calculation.

```{r rt-table-b-10_4}
#  Home-Work Trips (7-9 a.m.) 1.1
lt.wd.trips.am.hw.veh <-
  lt.wd.trips.am.veh %>%
  filter(TripType=='HW')  

bdat[['&nbsp;&nbsp;Home-Work Trips (7-9am)']] <-
  round(
    wtd.mean(lt.wd.trips.am.hw.veh$MAXTR,
             weights=lt.wd.trips.am.hw.veh$NEXPTCFPERWDWGT),
    1)
```

Computing mean travel times are similarly the weighted mean of
reported trip duration.  It is unclear in the 2001 tables whether
these values are for all trip modes or for vehicle trips only.  As
such, we compute them both.  Again, we start by adding a heading to
this list.

```{r rt-table-b-11}
# Mean Travel Time (Respondent Reported)
bdat[['Mean Travel Time (Respondent Reported)']] <- NA
```

Then, we compute weighted mean trip duration for all trips types and
modes.

```{r rt-table-b-11_1}
#  Weekday 'All Trips' Trip Length 22 minutes
bdat[["&nbsp;&nbsp;Weekday 'All Trips', All Modes, Trip Duration (min)"]] <- 
  round(
    wtd.mean(lt.wd.trips$tripdur, 
             weights=lt.wd.trips$NEXPTCFPERWDWGT),
    0)
```

Next, we compute weighted mean trip duration for all trips types and
vehicle modes.

```{r rt-table-b-11_2}
#  Weekday 'All Trips' Trip Length 22 minutes
bdat[["&nbsp;&nbsp;Weekday 'All Trips', Vehicle Modes, Trip Duration (min)"]] <- 
  round(
    wtd.mean(lt.wd.trips.veh$tripdur, 
             weights=lt.wd.trips.veh$NEXPTCFPERWDWGT),
    0)
```

Next, we compute weighted mean trip duration for home-work trips and
all modes.

```{r rt-table-b-11_3,cache=FALSE}
#  Weekday 'Home-Work Trips' Trip Length 27 minutes

# Weekday home to work trips (all modes)
lt.wd.trips.hw <- lt.wd.trips %>% filter(TripType=='HW') 

bdat[["&nbsp;&nbsp;Weekday 'Home-Work Trips' Trip Duration (min)"]] <-
  round(
    wtd.mean(lt.wd.trips.hw$tripdur, 
             weights=lt.wd.trips.hw$NEXPTCFPERWDWGT),
    0)
```

Next, we compute weighted mean trip duration for home-work trips and
vehicle modes.

```{r rt-table-b-11_4,cache=FALSE}
#  Weekday 'Home-Work Trips' Trip Length 27 minutes

bdat[["&nbsp;&nbsp;Weekday 'Home-Work Trips', Vehicle Modes Trip Duration (min)"]] <-
  round(
    wtd.mean(lt.wd.trips.hw.veh$tripdur, 
             weights=lt.wd.trips.hw.veh$NEXPTCFPERWDWGT),
    0)
```

Now we can print the table.
```{r rt-table-b-results-prep} 
res.b <- t(t(unlist(bdat)))  
colnames(res.b) <- c("Travel Data (Linked Trips)") 

res.b.str<-pandoc.table.return(res.b,
             split.tables=Inf,
             split.cells=Inf, 
             justify=c('left','right'),
             missing='&nbsp;',  # replace missing values (NAs) with blanks
             round=Inf,
             big.mark=',',
             caption="TABLE B: Weekday Trip Information")
```

```{r rt-table-b-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.b.str)
res[["res.b"]] <- list()
res[["res.b"]]$title  <- "TABLE B: Weekday Trip Information"
res[["res.b"]]$data   <- res.b
res[["res.b"]]$tabtxt <- res.b.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','Table C - Travel Mode Distribution')
```


To compute the travel mode distribution table, we first start by
defining mode classifications to match the 2001 tables.

```{r rt-table-c}
lt.wd.trips$modesummary <-
  factor(
    ifelse(
      lt.wd.trips$ltmode %in% c(driver.trip.modes),
      1,
      ifelse(
        lt.wd.trips$ltmode == 6,       # vehicle passenger trips
        2,
        ifelse(
          lt.wd.trips$ltmode %in% c(public.transport.trip.modes),
          3,
          ifelse(
            lt.wd.trips$ltmode==18,    # school bus trips
            4,
            ifelse(
              lt.wd.trips$ltmode==2,   # bicycle trips
              5,
              ifelse(
                lt.wd.trips$ltmode==1, # walk trips
                6,
                7)))))),
    levels=1:7,
    labels=c("Vehicle Driver Trips",
             "Vehicle Passenger Trips",
             "Public Transportation Trips",
             "School Bus Trips",
             "Bicycle Trips",
             "Walk Trips",
              "All Others")
    )
```

Next, we generate the weighted table of relative trip frequencies by
these modes (again converting the result to a `data.frame` so we can
print it using pandoc).

```{r rt-table-c-2}
tot <- sum(lt.wd.trips$NEXPTCFPERWDWGT,na.rm=TRUE)
res.c<-as.data.frame( 
  wtd.table(lt.wd.trips$modesummary,
                  weights=lt.wd.trips$NEXPTCFPERWDWGT)$sum.of.weights
  )
```

Now we'll add the total row and sort the rows from highest frequency
to lowest, placing the total on the bottom.

```{r rt-table-c-3}
colnames(res.c)<-c('Weekday.Percent')
res.c$`Weekday.Percent` <- res.c$`Weekday.Percent`/tot*100
res.c<-rbind(res.c,data.frame('Weekday.Percent'=c(sum(res.c[,'Weekday.Percent'])))) 
rownames(res.c)<-c(rownames(res.c)[1:7],'Total')
res.c$VALUE <- rownames(res.c)
res.c <- res.c %>% 
  arrange(desc(ifelse(`Weekday.Percent`>99.9999,-`Weekday.Percent`,`Weekday.Percent`))) %>%
  transmute(VALUE=VALUE,`Weekday Percent`=`Weekday.Percent`)
rownames(res.c)<-res.c$VALUE
res.c$VALUE <- NULL
```

Lastly, we generate the table.

```{r rt-table-c-5}
res.c.str<-pandoc.table.return(res.c,
             split.tables=Inf,split.cells=Inf, 
             justify=c('left','right'),
             big.mark=',',
             round=1,
             keep.trailing.zeros = TRUE,
             caption="TABLE C: Travel Mode Distribution")
```

```{r rt-table-c-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.c.str)
res[["res.c"]] <- list()
res[["res.c"]]$title  <- "TABLE C: Travel Mode Distribution"
res[["res.c"]]$data   <- res.c
res[["res.c"]]$tabtxt <- res.c.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','Table D: Weekday Commute Mode Share Information')
```


The process to compute the commute mode share is similar to that used
for the travel mode distribution we just calculated.  We start by
filtering to look only at Home to Work trips and generating the Mode
categories we want to summarize.

```{r rt-table-d}
lt.wd.hw <- lt.wd.trips %>% filter(TripType=='HW')

lt.wd.hw$modesummary <-
  factor(
    ifelse(
      lt.wd.hw$ltmode %in% c(driver.trip.modes) & lt.wd.hw$MAXTR==1,
      1,
      ifelse(
        lt.wd.hw$ltmode %in% c(6,7) | 
          # add in driver trips where MAXTR > 1
          (lt.wd.hw$ltmode %in% c(driver.trip.modes) & lt.wd.hw$MAXTR>1),
        2,
        ifelse(
          lt.wd.hw$ltmode %in% c(public.transit.trip.modes),
          3,
          ifelse(
            lt.wd.hw$ltmode==1,
            4,
            ifelse(lt.wd.hw$ltmode==2,
                   5,
                   6))))),
    levels=1:6,
    labels=c("Drove Alone",
             "Carpooled or Van Pooled",
             "Public Transit",
             "Walk",
             "Bicycle",
             "Others")
    )
```

Next, we generate the weighted frequency table an convert it to
percentages by dividing by the total number of trips.  We do this
first for trips occuring any time of the day.

```{r rt-table-d-2}
tot <- sum(lt.wd.hw$NEXPTCFPERWDWGT,na.rm=TRUE)
tab<-as.data.frame(
    wtd.table(lt.wd.hw$modesummary,
              weights=lt.wd.hw$NEXPTCFPERWDWGT)$sum.of.weights/tot*100,
    )

# Manipulate the column names and add the total row
colnames(tab)<-'X.24.Hours'
tab<-rbind(tab,data.frame('X.24.Hours'=c(sum(tab[,'X.24.Hours']))))
colnames(tab)<-c('24 Hours')
rownames(tab)<-c(rownames(tab)[1:6],'Total')
```

Next, we do the same computation, but only include trips departing in
the 7am-9am window.

```{r rt-table-d-3}
lt.wd.hw.am <- lt.wd.hw  %>%                                          
    # select all trips active during AM window
  filter((DEP_HR >= 7 & DEP_HR <9)) 
tot2 <- sum(lt.wd.hw.am$NEXPTCFPERWDWGT,na.rm=TRUE)
tab2<-t(t(as.data.frame(
    wtd.table(lt.wd.hw.am$modesummary,
              weights=lt.wd.hw.am$NEXPTCFPERWDWGT)$sum.of.weights/tot2*100,
    )))

# Manipulate the column names and add the total row
colnames(tab2)<-'AM'
tab2<-rbind(tab2,data.frame('AM'=c(sum(tab2[,'AM']))))
rownames(tab2)<-c(rownames(tab2)[1:6],'Total')
```

Now, we want to merge the two tables into one.  We use `cbind` to add
the AM column from the AM table to the 24 hour table, then manipulate
the results for printing.

```{r rt-table-d-4}
res.d <- cbind(tab,tab2 %>% select(AM))

# manipulate the data frame for printing.
res.d[['Commuter Mode Share---Weekday Trips']] <-
  rownames(res.d)
rownames(res.d)<-NULL
res.d <- res.d[,c(3,1,2)]

# generate the table
res.d.str <- pandoc.table.return(res.d,
             split.tables=Inf,split.cells=Inf, 
             justify=c('left','right','right'),
             big.mark=',',
             round=1,
             caption="TABLE D: Weekday Mode Share Information",
             emphasize.strong.cols = 1) 
```

```{r rt-table-d-results,results='asis',echo=FALSE,cache=FALSE}
cat(res[['d.str']])
res[["res.d"]] <- list()
res[["res.d"]]$title  <- "TABLE D: Weekday Mode Share Information"
res[["res.d"]]$data   <- res.d
res[["res.d"]]$tabtxt <- res.d.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','Table 1: Persons/Vehicle per Household By County')
```

To compute persons and vehicles per household for the state and each
county, we need the household table, which includes the number of
persons (`HHSIZ`) and vehicles (`HHVEH`) in each household sampled.
Using that, we can compute the statewide weighted means of each value
using the statewide weights in `EXPHHWGT`.

```{r rt-table-1}
# Statewide
hh <- chts_hh %>% 
  mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
  left_join(fipsctyca,by=c('ICTFIP'='county_ansi'))
state<-hh %>% 
  summarise('phhw'=weighted.mean(HHSIZ,EXPHHWGT),
            'vhhw'=weighted.mean(HHVEH,EXPHHWGT)
            )
state$County <- 'California'
```

To compute the means by county, we need to join the county weights,
then group the dataset by county and compute the weighted mean for
each group using the county weights in `NEXPHHWGT`.

```{r rt-table-1-1}
# By County
by.cty <- hh %>% 
  left_join(chts_hh.wgt.cty %>% select(-CTFIP),by=c("SAMPN")) %>%
  group_by(County) %>% 
  summarise('phhw'=weighted.mean(HHSIZ,NEXPHHWGT),
            'vhhw'=weighted.mean(HHVEH,NEXPHHWGT))
```

Finally, we join the county data onto the state data so we can produce
the final table.

```{r rt-table-1-2}
# Combine state and table data
res.1 <- rbind(state,by.cty) %>% 
  select(
    County,
    'Persons per Household'=phhw,
    'Vehicles per Household'=vhhw
  ) %>% 
  as.data.frame()

res.1.str <- pandoc.table.return(
  res.1,
  justify=c('left','right','right'),
  # make the California row bold
  emphasize.strong.rows=which(res.1$County=='California',arr.ind=TRUE),
  caption='TABLE 1: Persons/Vehicle per Household by County',
  split.table=Inf,
  split.cells=c(15,5,5),
  big.mark=',',
  round=1
  ) 
```

```{r rt-table-1-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.1.str)
res[["res.1"]] <- list()
res[["res.1"]]$title  <- "TABLE 1: Persons/Vehicle per Household by County"
res[["res.1"]]$data   <- res.1
res[["res.1"]]$tabtxt <- res.1.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 5: Licensed Drivers Per Household')
```


We use a similar process to generate the licensed drivers per
household (`HHLIC`), first computing the weighted mean for the state.

```{r rt-table-5}
# Statewide
lic.ca <- chts_hh %>% summarise(
  County='California',  
  Licensed=round(wtd.mean(HHLIC,weights=EXPHHWGT),1)
  )
```

Then, we repeat the the process by county.

```{r rt-table-5-1}
# Per County
lic.cty <-  chts_hh %>% 
  mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
  left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>%
  left_join(chts_hh.wgt.cty %>% select(-CTFIP),by=c("SAMPN")) %>%
  group_by(County) %>%
  summarise(
    Licensed=wtd.mean(HHLIC,weights=NEXPHHWGT)
    )
```

Again, we join the State and County data to produce the final table.

```{r rt-table-5-2}
res.5 <- rbind(lic.ca,lic.cty)

res.5.str <- pandoc.table.return(
  res.5,
  justify=c('left','right'),
  caption="TABLE 5: Licensed Drivers Per Household by County",
  emphasize.strong.rows=which(res.5$County=='California',arr.ind=TRUE),
  big.mark = ',',
  round = 1
  )
```

```{r rt-table-5-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.5.str)
res[["res.5"]] <- list()
res[["res.5"]]$title  <- "TABLE 5: Licensed Drivers per Household by County"
res[["res.5"]]$data   <- res.5
res[["res.5"]]$tabtxt <- res.5.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 6: Employees Per Household')
```


Once again, the process is similar for computing the employees per
household table in that we compute weighted means of the `HHEMP`
variable by state and county.  Here is the state computation.

```{r rt-table-6}
emp.ca <- chts_hh %>% summarise(
  County='California',
  Employed=round(wtd.mean(HHEMP,weights=EXPHHWGT),1)
  )
```

Next, we compute the weighted county means.

```{r rt-table-6-1}
emp.cty <- chts_hh %>% 
  mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
  left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>%
  left_join(chts_hh.wgt.cty %>% select(-CTFIP),by=c("SAMPN")) %>%
  group_by(County) %>%
  summarise(
    Employed=wtd.mean(HHEMP,weights=NEXPHHWGT)
    )
```

Finally, as above, we join the state and county data to produce the
final table.

```{r rt-table-6-2}
res.6 <- rbind(emp.ca,emp.cty)
res.6.str <- pandoc.table.return(
  res.6,
  justify=c('left','right'),
  caption="TABLE 6: Employees per Household by County",
  emphasize.strong.rows=which(res.6$County=='California',arr.ind=TRUE),
  big.mark=',',
  round=1,
  keep.trailing.zeros = TRUE
  )
```

```{r rt-table-6-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.6.str)
res[["res.6"]] <- list()
res[["res.6"]]$title  <- "TABLE 6: Employees per Household by County"
res[["res.6"]]$data   <- res.6
res[["res.6"]]$tabtxt <- res.6.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 9: Weekday Trip-Type Distribution')
```


We will now compute the weekday trip type distribution by state and
for each county.  We begin with the state.  To compute the trip type
distribution, we'll use the linked trip data, which contains the
`TripType` variable.  Because the weighting for trips comes from the
person weights, we need to join the person table onto the linked trip
table.  We modify these weights using the Trip Correction Factor (TCF)
of the primary leg of the linked trip (`ltTCF`) to produce the linked
trip weight `EXPTCFPERWGT`.

```{r rt-table-9-1}
dat<-
  lt.clean %>% 
  left_join(chts_per %>% select(SAMPN,PERNO,EXPPERWGT),by=c('SAMPN','PERNO')) %>% 
  mutate(EXPTCFPERWGT=EXPPERWGT*ltTCF)
```

With that, we can compute a weighted frequency table using the
`wtd.table` function.  The nested transpose `t(t(.))` calls are a quick idiom
for converting the data into a tabular format. 

```{r rt-table-9-2}
tt <- t(t(wtd.table(dat$TripType,weights=dat$EXPTCFPERWGT,type='table')))
```

Next, we manipulate the table for printing.

```{r rt-table-9-3}
# Row names are the trip types, we grab them so we can make them a column.
ttt <- rownames(tt)
rownames(tt)<-NULL   # ...then we remove the row names

# create the final data frame.
res.9.1 <- data.frame(
  "Trip Type"=ttt,
  "Number"=tt,
  "Percent"=round(tt/sum(tt)*100,2)  # Note, we add the Percent column
)

# Add a total row to the data frame
res.9.1 <- rbind(res.9.1,
                data.frame(
                  `Trip Type`=c("TOTAL"),
                  "Number"=round(sum(res.9.1$Number),0),
                  "Percent"=sum(res.9.1$Percent))) %>%
  arrange(ifelse(Trip.Type=='TOTAL',999,1),desc(Percent))

# generate the table
res.9.1.str <- 
  pandoc.table.return(
    res.9.1,caption="TABLE 9: Weekday Trip Type Distribution",
    split.table=Inf,
    split.cells=,
    justify=c('center','right','right'),
    style='multiline',
    big.mark=",",
    emphasize.strong.rows=which(res.9.1$Trip.Type=='TOTAL',arr.ind=TRUE)
  )
```
```{r rt-table-9-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.9.1.str)
```

To compute the county tables, we will use the household's county as
the grouping variable.  To do this, we join the household data with
the matching `County` name from the `fipsctyca` table, then join the
county-specific person weights.


```{r rt-trip-dist-by-county}
data <- lt.clean %>% 
  left_join(
    chts_hh %>%
      mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
      left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
      select(SAMPN,County),
    by=c("SAMPN")
  ) %>%
  left_join(chts_per.wgt.cty %>% select(SAMPN,PERNO,NEXPPERWGT),
    by=c("SAMPN","PERNO")
    )
```

With that dataset, we use the `lapply` method to call a
table-generating function for each county.  The function generates the
pandoc table and returns it as a string.  We collapse all county
tables into a single string for printing.

Inside the table-generating function, we simply filter the full
dataset above by county and compute the weighted frequency table as we
did with the state.  In this case, we're using the household county
weights.

```{r rt-t9-2-trip-dist-by-county}
res.9.2.str <- 
  paste(  # paste will concatenate the results of the lapply function
    lapply(
      c(sort(fipsctyca$County)),   # The counties to loop over

      # the table generating function.
      function(cty) {
        dat<-data %>% filter(County==cty)  # filter to the county of interest

        # generate the table
        tt <- t(t(wtd.table(dat$TripType,weights=dat$NEXPPERWGT,type='table')))

        # manipulate the output
        ttt <- rownames(tt)
        rownames(tt)<-NULL
        tabtot <- data.frame(
          "Trip Type"=ttt,
          "Number"=tt,
          "Percent"=round(tt/sum(tt)*100,2))
        tabtot <- rbind(tabtot,
                        data.frame(
                          "Trip Type"=c("TOTAL"),
                          "Number"=round(sum(tabtot$Number),0),
                          "Percent"=sum(tabtot$Percent))) %>%
          arrange(ifelse(Trip.Type=='TOTAL',999,1),desc(Percent))

        # generate and return the table
        return(
          pandoc.table.return(
            tabtot,
            caption=paste("TABLE 9: Weekday Trip Type Distribution (",cty,")",sep=""),
            split.table=Inf,split.cells=Inf,
            big.mark=',',
            round=1,
            justify=c('center','right','right'),
            style='multiline',
            emphasize.strong.rows=which(tabtot$Trip.Type=='TOTAL',arr.ind=TRUE))
        )
      }),
    collapse="\n\n"  # put two blank lines between each county table
  )
```
```{r rt-t9-2-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.9.2.str)
res.9.str <- paste(res.9.1.str,res.9.2.str,sep="\n\n\n")
res[["res.9"]] <- list()
res[["res.9"]]$title  <- "TABLE 9: Weekday Trip Type Distribution"
res[["res.9"]]$data.1 <- res.9.1
res[["res.9"]]$data.2 <- NA
res[["res.9"]]$tabtxt <- res.9.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 10a: Weekday Person Trips Per Household')
```


Here, we're looking for weekday person trips per household broken down
by county, housing unit type, vehicle ownership, and trip type.  We
also want the total across all trip types for each category.  Again,
we're going to be working with the linked trip tables.

We start by producing the main table of person trips per household by
filtering the linked trip table for trips whose primary leg used a
mode in `person.trip.modes`.  Onto that subset, we join the statewide
and county-specific weekday person weights.  Then, we group by the
`TripType` and compute the weighted trip sums for the state and by
each county for each `TripType` category.


```{r rt-table-10a-1}
# compute person trips per category
# Filter for weekday person trips and count the expanded total trips per type
data <- lt.clean %>%
  filter(ltmode %in% person.trip.modes) %>%
  
  # join statewide weekday weights (and WD)
  left_join(chts_per.wgt.wd,by=c('SAMPN','PERNO')) %>% 
  filter(WD==1) %>% # only weekdays
  
  # also, join county weekday weights
  left_join(chts_per.wgt.wd.cty,by=c('SAMPN','PERNO')) %>% 
  group_by(SAMPN,PERNO,TripType) %>% 
  summarise(
    n.st=sum(NEXPPERWDWGT*ltTCF),
    n.cty=sum(NEXPPERWDCTYWGT*ltTCF)
  )
```

Next, because vehicle ownership and housing unit type are
household-level variables, we need to attach the household data onto
the table we computed above.  Note that we use the `RESTY` variable to
determine Single vs Multi-familty housing units, and we simplify the
vehicle ownership variable into 0, 1, 2, and 3+ categories.

```{r rt-table-10a-1-1}
# next, attach the household characteristics to each trip observation
data2 <- data  %>% 
  left_join(
    chts_hh %>%
      mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
      left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
      select(SAMPN,RESTY,HHVEH,County) %>% 
      
      # create the HHUT and VOWN categories
      mutate(
        HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple'),
        VOWN=ifelse(HHVEH<3,as.character(HHVEH),'3+')
      ), 
    by=c('SAMPN')
  )
```

The next step is to compute the category person trips along with the
row and column marginals.  We create a convenience function to do this
`doagg` that we'll reuse for each county (and the state).

```{r rt-table-10a-1-2}
doagg <- function(dataa,aggv) {
  # We're using the _ variants of the summarize function that
  # allow us to construct formulas as strings.  Here, we will
  # sum the `aggv` variable and put it in the column `n`
  dots <- c(paste("sum(",aggv,",na.rm=TRUE)",sep=""))
  names <- c("n")

  # first we compute the cell sums
  aggp.all <- dataa %>% 
    group_by(County,HHUT,VOWN,TripType) %>% 
    summarise_(.dots=setNames(dots,names))

  # then the subtotals for all vehicle ownership categories
  aggp.hhut <- dataa %>% 
    mutate(VOWN='Subtotal') %>% 
    group_by(County,HHUT,VOWN,TripType) %>%
    summarise_(.dots=setNames(dots,names))

  # then the subtotals for all household types
  aggp.tot <- dataa %>% 
    mutate(HHUT='Total',VOWN='&nbsp;') %>% 
    group_by(County,HHUT,VOWN,TripType ) %>%
    summarise_(.dots=setNames(dots,names))
  return(rbind(aggp.all,aggp.hhut,aggp.tot))
}
```

With our aggregation function defined, we can compute the county and
state aggregations, using the associated sums.

```{r rt-table-10-a-1-2-1}
aggp <- rbind(doagg(data2,"n.cty"),
              doagg(data2 %>% mutate(County='California'),"n.st"))
```

Because we're interested in trips per household, we need the household
totals corresponding to each of the categories and marginals we
computed in aggp.  To do this, we first start by creating the
necessary household dataset, with county weights joined and matching
categories for `HHUT` and `VOWN`.

```{r rt-table-10-a-1-2-2}
# Now, we'll count the total households in each stratifications
hht <- chts_hh %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
  left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
  select(SAMPN,RESTY,HHVEH,County) %>%
  left_join(chts_hh.wgt.wd,by=c('SAMPN')) %>%
  filter(WD==1) %>%
  left_join(chts_hh.wgt.wd.cty,by=c('SAMPN')) %>%
    mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple'),
           VOWN=ifelse(HHVEH<3,as.character(HHVEH),'3+'))
```

With the data in `hht`, we now create another aggregation function to
compute household category and marginal totals like we did for the
trip totals.

```{r rt-table-10-a-1-2-3}
dohhagg <- function(dataa,sumarg) {
  # We're using the _ variants of the summarize function that
  # allow us to construct formulas as strings.  Here, we will
  # sum the `aggv` variable and put it in the column `n`
  dots <- c(paste("sum(",sumarg,",na.rm=TRUE)",sep=""))
  names <- c("hhn")

  # first, compute the cell sums
  datahh.all <- dataa %>%
    group_by(County,HHUT,VOWN) %>% 
    summarise_(.dots=setNames(dots,names))
  
  # next, compute the subtotals for all VOWN categories
  datahh.cty.hhut <- dataa %>% 
    mutate(VOWN='Subtotal') %>%
    group_by(County,HHUT,VOWN) %>% 
    summarise_(.dots=setNames(dots,names))
  
  # then, compute the subtotals for all HHUT categories
  datahh.cty <- dataa %>% 
    mutate(HHUT='Total',
           VOWN='&nbsp;') %>%
    group_by(County,HHUT,VOWN) %>% 
    summarise_(.dots=setNames(dots,names))
  return(rbind(datahh.all,datahh.cty.hhut,datahh.cty))
}
```

How we compute the county state household total aggregates using our
function to sum the expanded household county and state weights.

```{r rt-table-10-a-1-2-4}
datahh <- rbind(
  dohhagg(hht,"NEXPHHWDCTYWGT"),
  dohhagg(hht %>% mutate(County='California'),"NEXPHHWDWGT")
)
  
```

Now, `aggp` has the weighted linked trip totals and `datahh` has the
corresponding household totals.  We can simply compute the mean for
each combination.  We do this by joining the household totals onto the
trip totals for by each category and simply dividing them to generate
the mean for each category and marginal.

```{r rt-table-10a-2}
# take the trip aggs (appg), join the household aggs by stratification, devide totals
agg1 <- aggp %>% left_join(datahh,by=c('County','HHUT','VOWN')) %>% 
  mutate(nn=n/hhn) %>% 
  select(-n,-hhn) %>% 
  ungroup()
```

We also want the totals across all trip types, so we compute those next.

```{r rt-table-10a-2-1}
# Sum the totals for each trip type
agg2 <- agg1 %>% group_by(County,HHUT,VOWN) %>% summarise(nn=sum(nn)) %>%
  mutate(TripType="zTOT")
```

Next, we add the trip type totals onto the data frame, arrange (sort)
it by `County`, `HHUT`, `VOWN`, and `TripType`, and split the trips
per household value stored in `nn` into columns by each `TripType`
using the `spread` function from the `tidyr` package.

```{r rt-table-10a-2-2}
res.10a <- rbind(agg1,agg2)  %>%
  arrange(County,HHUT,VOWN,TripType) %>%
  spread(TripType,nn) # reorganize for table
```

With that, we're ready to generate the tables.  Here, we create one
table for California and one for each county by looping over them,
filtering the data for the state/county, and generating the table.

```{r rt-table-10a-2-3}
res.10a.str <- 
  paste(
    lapply(
      c('California',sort(fipsctyca$County)),
      function(cty) {
        dat<-res.10a %>%
          filter(County==cty) %>%  # grab the subset of the data we want
          
          # Here, we remove the County and HHUT labels for all cells except for those
          # when the prior cell changes (this removes clutter from the table
          mutate(County=ifelse(!is.na(lag(County)) & County==lag(County),"&nbsp;",County),
                 HHUT=ifelse(!is.na(lag(HHUT)) & HHUT==lag(HHUT),"&nbsp;",HHUT)
          ) %>%

          # then, we make the column headings prettier
          select(`Housing Unit Type`=HHUT,`Vehicle Ownership`=VOWN,HH,HO,HS,HW,OO,WO,WW,Total=zTOT)
        
        # finally, we generate the table and return it
        return(
          pandoc.table.return(
            dat,
            caption=paste("TABLE 10a: Weekday Person Trips Per Household (",cty,")",sep=""),
            split.table=Inf,
            split.cells=c(10,10,rep(5,8)),
            big.mark=',',
            round=1,
            justify=c(rep('center',2),rep('right',8)),
            style='multiline')
        )
      }
    ),
    collapse = "\n\n\n"
  )
```

```{r rt-t10a-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.10a.str) 
res[["res.10a"]] <- list()
res[["res.10a"]]$title  <- "TABLE 10a: Weekday Person Trips Per Household"
res[["res.10a"]]$data.1 <- res.10a
res[["res.10a"]]$tabtxt <- res.10a.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 11: Weekday Driver Trips Per Household')
```


Now we're looking for weekday person trips per household broken down by county, housing unit type, vehicle ownership, and trip type.  As with Table 10a, we also want the total across all trip types
for each category.


```{r rt-table-11a-1}
# compute driver trips per category
# Filter for weekday driver trips and count the expanded total trips per type
data <- lt.clean %>%
  filter(ltmode %in% driver.trip.modes) %>%
  left_join(chts_per.wgt.wd,by=c('SAMPN','PERNO')) %>% # join weekday weights (and WD)
  filter(WD==1) %>% # only weekdays
  left_join(chts_per.wgt.wd.cty,by=c('SAMPN','PERNO')) %>% # join weekday county weights
  group_by(SAMPN,PERNO,TripType) %>% 
  summarise(
    n.st=sum(NEXPPERWDWGT*ltTCF),
    n.cty=sum(NEXPPERWDCTYWGT*ltTCF) 
    )

# next, attach the household characteristics to each trip observation
data2 <- data  %>% 
  left_join(chts_hh %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
              left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
              select(SAMPN,RESTY,HHVEH,County) %>% 
              mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple'),
                     VOWN=ifelse(HHVEH<3,as.character(HHVEH),'3+')), by=c('SAMPN'))

doagg <- function(dataa,aggf) {
  # Now, aggregate the expanded totals by the stratifications
  aggp.all <- dataa %>% 
    group_by(County,HHUT,VOWN,TripType) %>% 
    summarise_(.dots=setNames(list(aggf),c("n")))
  aggp.cty.hhut <- dataa %>% 
    mutate(VOWN='Subtotal') %>% 
    group_by(County,HHUT,VOWN,TripType) %>%
    summarise_(.dots=setNames(list(aggf),c("n")))
  aggp.cty <- dataa %>% 
    mutate(HHUT='Total',VOWN='&nbsp;') %>% 
    group_by(County,HHUT,VOWN,TripType ) %>%
    summarise_(.dots=setNames(list(aggf),c("n")))
  return(rbind(aggp.all,aggp.cty.hhut,aggp.cty))
}

aggp <- rbind(
  doagg(data2,~sum(n.cty,na.rm=TRUE)),
  doagg(data2 %>% mutate(County='California'),~sum(n.st,na.rm=TRUE))
)

dohhagg <- function(dataa,aggf) {

  # Now, we'll count the total households in each stratifications
  datahh.all <- dataa  %>%
    group_by(County,HHUT,VOWN) %>% 
    summarise_(.dots=setNames(list(aggf),c('hhn')))
  
  datahh.cty.hhut <- dataa %>% 
    mutate(VOWN='Subtotal') %>%
    group_by(County,HHUT,VOWN) %>% 
    summarise_(.dots=setNames(list(aggf),c('hhn')))
  
  datahh.cty <- dataa %>%  
    mutate(HHUT='Total',
           VOWN='&nbsp;') %>%
    group_by(County,HHUT,VOWN) %>% 
    summarise_(.dots=setNames(list(aggf),c('hhn')))

  return(rbind(rbind(datahh.all,datahh.cty.hhut,datahh.cty)))
}

hhdat <- chts_hh %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
  left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
  select(SAMPN,RESTY,HHVEH,County) %>% 
  mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple'),
         VOWN=ifelse(HHVEH<3,as.character(HHVEH),'3+')) %>%
  left_join(chts_hh.wgt.wd,by=c('SAMPN'))  %>% 
  filter(WD==1) %>%
  left_join(chts_hh.wgt.wd.cty,by=c('SAMPN')) 

datahh <- rbind(
  dohhagg(hhdat,~sum(NEXPHHWDWGT,na.rm=TRUE)),
  dohhagg(hhdat %>% mutate(County='California'),~sum(NEXPHHWDCTYWGT,na.rm=TRUE))
)
```

Now, `data2` has the linked trips for each weekday person trip.  We can simply compute the mean for
each combination.

```{r rt-table-11a-2}
# take the trip aggs (appg), join the household aggs by stratification, devide totals
agg1 <- aggp %>% left_join(datahh,by=c('County','HHUT','VOWN')) %>% 
  mutate(nn=n/hhn) %>% 
  select(-n,-hhn) %>% 
  ungroup()

# Sum the totals for each trip type
agg2 <- agg1 %>% group_by(County,HHUT,VOWN) %>% summarise(nn=sum(nn)) %>%
  mutate(TripType="zTOT")

res.11 <- rbind(agg1,agg2)  %>%
  arrange(County,HHUT,VOWN,TripType) %>%
  spread(TripType,nn) # reorganize for table

res.11.str <-
  paste(
    lapply(
      c('California',sort(fipsctyca$County)),
      function(cty) {
        dat <- res.11 %>% filter(County==cty) %>%
          mutate(HHUT=ifelse(!is.na(lag(HHUT)) & HHUT==lag(HHUT),"&nbsp;",HHUT)
          ) %>%
          select(
            `Housing Unit Type`=HHUT,
            `Vehicle Ownership`=VOWN,
            HH,HO,HS,HW,OO,WO,WW,
            Total=zTOT)
        
        return(
          pandoc.table.return(
            dat,
            caption=paste("TABLE 11: Weekday Driver Trips Per Household (",cty,")",sep=""),
            split.table=Inf,
            split.cells=c(10,10,rep(5,8)),
            big.mark=',',
            round=1,
            justify=c(rep('center',2),rep('right',8)),
            style='multiline')
        )
      }  
    ),
    collapse="\n\n"
  )
res[["res.11"]] <- list()
res[["res.11"]]$title  <- "TABLE 11: Weekday Driver Trips Per Household"
res[["res.11"]]$data.1 <- res.11
res[["res.11"]]$tabtxt <- res.11.str
```

```{r rt-t11-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.11.str) 
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 13a: Weekday Person and Driver Trips Per Household')
```


```{r rt-table13a}
# By County, HH
datapt <- lt.clean %>%
  filter(ltmode %in% person.trip.modes) %>%
  left_join(chts_per.wgt.wd,by=c('SAMPN','PERNO')) %>% # join weekday weights (and WD)
  filter(WD==1) %>% # only weekdays
  left_join(chts_per.wgt.wd.cty,by=c('SAMPN','PERNO')) %>% # join weekday weights (and WD)
  group_by(SAMPN,PERNO) %>% 
  summarise(
    npt.st=sum(NEXPPERWDWGT*ltTCF),
    npt.cty=sum(NEXPPERWDCTYWGT*ltTCF)
    )

# next, attach the household characteristics to each trip observation
datapt2 <- datapt  %>% 
  left_join(chts_hh %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
              left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
              select(SAMPN,RESTY,HHSIZ,County) %>% 
              mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple'),
                     HHSIZ=ifelse(HHSIZ<5,as.character(HHSIZ),'5+')), 
            by=c('SAMPN'))

datadt <- lt.clean %>%
  filter(ltmode %in% driver.trip.modes) %>%
  left_join(chts_per.wgt.wd,by=c('SAMPN','PERNO')) %>% # join weekday weights (and WD)
  filter(WD==1) %>% # only weekdays
  left_join(chts_per.wgt.wd.cty,by=c('SAMPN','PERNO')) %>% # join weekday weights (and WD)
  group_by(SAMPN,PERNO) %>% 
  summarise(
    ndt.st=sum(NEXPPERWDWGT*ltTCF),
    ndt.cty=sum(NEXPPERWDCTYWGT*ltTCF)
    )

# next, attach the household characteristics to each trip observation
datadt2 <- datadt  %>% 
  left_join(chts_hh %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
              left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
              select(SAMPN,RESTY,HHSIZ,County) %>% 
              mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple'),
                     HHSIZ=ifelse(HHSIZ<5,as.character(HHSIZ),'5+')), 
            by=c('SAMPN'))

data2 <- merge(datapt2,datadt2,all=TRUE)  # outer join

doagg <- function(dataa,aggf,aggn) {
  aggp.all <- dataa %>% 
    group_by(County,HHUT,HHSIZ) %>% 
    summarise_(.dots=setNames(aggf,aggn))
  
  aggp.cty.hhut <- dataa %>% 
    mutate(HHSIZ='Total') %>% 
    group_by(County,HHUT,HHSIZ) %>%
    summarise_(.dots=setNames(aggf,aggn))
  
  aggp.cty.hhsiz <- dataa %>% 
    mutate(HHUT='Total') %>% 
    group_by(County,HHUT,HHSIZ) %>%
    summarise_(.dots=setNames(aggf,aggn))
  
  aggp.cty <- dataa %>% 
    mutate(HHUT='Total',HHSIZ='Total') %>% 
    group_by(County,HHUT,HHSIZ) %>%
    summarise_(.dots=setNames(aggf,aggn))

  return(rbind(aggp.all,aggp.cty.hhut,aggp.cty.hhsiz,aggp.cty) %>% ungroup())
}

aggp <- rbind(
  doagg(data2,
        list(
          ~sum(npt.cty,na.rm=TRUE),
          ~sum(ndt.cty,na.rm=TRUE)
        ), c('npt','ndt')),
  doagg(data2 %>% mutate(County='California'),
        list(
          ~sum(npt.st,na.rm=TRUE),
          ~sum(ndt.st,na.rm=TRUE)
        ),c('npt','ndt'))
  )


hhdat <- chts_hh %>% 
  mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
  left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
  select(SAMPN,RESTY,HHSIZ,County) %>% 
  mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple'),
         HHSIZ=ifelse(HHSIZ<5,as.character(HHSIZ),'5+')) %>%
  left_join(chts_hh.wgt.wd,by=c('SAMPN'))  %>% 
  filter(WD==1) %>%
  left_join(chts_hh.wgt.wd.cty,by=c('SAMPN')) 

dohhagg <- function(dataa,aggf,aggn) {
  
  # Now, we'll count the total households in each stratifications
  datahh.all <- dataa %>%
    group_by(County,HHUT,HHSIZ) %>% 
    summarise_(.dots=setNames(aggf,aggn))
  
  datahh.cty.hhut <- dataa %>%  
    mutate(HHSIZ='Total') %>%
    group_by(County,HHUT,HHSIZ) %>% 
    summarise_(.dots=setNames(aggf,aggn))
  
  datahh.cty.hhsiz <- dataa %>%  
    mutate(HHUT='Total',
           HHSIZ=ifelse(HHSIZ<5,as.character(HHSIZ),'5+')) %>%
    group_by(County,HHUT,HHSIZ) %>% 
    summarise_(.dots=setNames(aggf,aggn))
  
  datahh.cty <- dataa %>%  
    mutate(HHUT='Total',
           HHSIZ='Total') %>%
    group_by(County,HHUT,HHSIZ) %>% 
    summarise_(.dots=setNames(aggf,aggn))
  
  return(rbind(datahh.all,datahh.cty.hhut,datahh.cty.hhsiz,datahh.cty))
}

datahh <- rbind(
  dohhagg(hhdat,list(~sum(NEXPHHWDCTYWGT)),c('hhn')),
  dohhagg(hhdat %>% mutate(County='California'),list(~sum(NEXPHHWDWGT)),c('hhn'))
)
```

```{r rt-table-13a-2}
# take the trip aggs (appg), join the household aggs by stratification, devide totals
agg1 <- aggp %>% 
  left_join(datahh,by=c('County','HHUT','HHSIZ')) %>% 
  mutate(nnpt=npt/hhn,nndt=ndt/hhn) %>% 
  select(-npt,-ndt,-hhn) %>% ungroup()


res.13.a <- agg1  %>%
  arrange(County,HHUT,HHSIZ) %>% select(-nndt) %>%
  spread(HHUT,nnpt) %>% # reorganize for table
  select(County,HHSIZ,Single.nnpt=Single,Multiple.nnpt=Multiple,Total.nnpt=Total)
res.13.b <- agg1  %>%
  arrange(County,HHUT,HHSIZ) %>% select(-nnpt) %>%
  spread(HHUT,nndt) %>% # reorganize for table
  select(County,HHSIZ,Single.nndt=Single,Multiple.nndt=Multiple,Total.nndt=Total)
res.13 <- merge(res.13.a,res.13.b)
  
res.13.str <-
  paste(
    lapply(
      c('California',sort(fipsctyca$County)),
      function(cty) {
        dat<-res.13 %>% filter(County==cty) %>%
          select(`Household Size`=HHSIZ,
                 `Person-Trips per Household Single`=Single.nnpt,
                 `Person-Trips per Household Multiple`=Multiple.nnpt,
                 `Person-Trips per Household Total`=Total.nnpt,
                 `Driver-Trips per Household Single`=Single.nndt,
                 `Driver-Trips per Household Multiple`=Multiple.nndt,
                 `Driver-Trips per Household Total`=Total.nndt
          )
        
        return(pandoc.table.return(
          dat,
          caption=paste("TABLE 13: Weekday Person and Driver Trips Per Household (",cty,")",sep=""),
          split.table=Inf,
          split.cells=c(10,rep(6,6)),
          big.mark=',',
          round=1,
          #               justify=c('left','left','right','right','right'),
          style='multiline'))
      }),
    collapse="\n\n"
  )
res[["res.13"]] <- list()
res[["res.13"]]$title  <- "TABLE 13: Weekday Person and Driver Trips Per Household"
res[["res.13"]]$data <- res.13
res[["res.13"]]$tabtxt <- res.13.str
```

```{r rt-t13a-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.13.str)
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 15: Weekday Driver Trips Per Vehicle By County, HH Income, and Housing Unit')
```


```{r rt-table-15}
# compute driver trips per category
# Filter for weekday driver trips and count the expanded total trips per type
data <- lt.clean %>%
  filter(ltmode %in% driver.trip.modes) %>%
  left_join(chts_per.wgt.wd,by=c('SAMPN','PERNO')) %>% # join weekday weights (and WD)
  left_join(chts_per.wgt.wd.cty,by=c('SAMPN','PERNO')) %>% # join wd cty weights
  filter(WD==1) %>% # only weekdays
  group_by(SAMPN,PERNO) %>% 
  summarise(n.st=sum(NEXPPERWDWGT*ltTCF),
            n.cty=sum(NEXPPERWDWGT*ltTCF))

# next, attach the household characteristics to each trip observation
chts_hh_t <- chts_hh
chts_hh_t$INCOM <- assign_factors(chts_hh_t$INCOM,'hh','INCOM')

data2 <- data  %>% 
  left_join(chts_hh_t %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
              left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
              select(SAMPN,RESTY,INCOM  ,County) %>% 
              mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple')), by=c('SAMPN'))

# Now, aggregate the expanded driver trip totals by the stratifications
doagg <- function(mydata) {
  ret <- function(cty) {
    mydat <- mydata
    if ( cty == 'California') mydat$County = cty
    mydat <- mydat %>% 
      filter(County==cty)
    
    aggp.cty.all <- mydat %>%
      group_by(County,HHUT,INCOM) %>% 
      summarise(n=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),n.cty,n.st),na.rm=TRUE))
    aggp.cty.hhut <- mydat %>% 
      mutate(INCOM='Total') %>%
      group_by(County,HHUT,INCOM) %>%
      summarise(n=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),n.cty,n.st),na.rm=TRUE))
    aggp.cty.incom <- mydat %>%
      mutate(HHUT='Total') %>%
      group_by(County,HHUT,INCOM) %>%
      summarise(n=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),n.cty,n.st),na.rm=TRUE))
    aggp.cty <- mydat %>%
      mutate(INCOM='Total',HHUT='Total') %>%
      group_by(County,HHUT,INCOM) %>%
      summarise(n=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),n.cty,n.st),na.rm=TRUE))

    
    return(rbind(aggp.cty.all,aggp.cty.hhut,aggp.cty.incom,aggp.cty))
  }
  return(ret)
}

aggp <- do.call(
  "rbind",
  lapply(
    c('California',sort(unique(fipsctyca$County))),
    doagg(data2)
  )
)

hhtt <- chts_hh_t %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
  left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
  select(SAMPN,RESTY,INCOM,County,HHVEH) 

dohhagg <- function(mydata) {
  mydata2 <- mydata %>% 
    left_join(chts_hh.wgt.wd,by=c('SAMPN'))  %>% filter(WD==1) %>%
    left_join(chts_hh.wgt.wd.cty,by=c("SAMPN"))
  
  return(function(cty) {
    mydat <- mydata2
    if ( cty == 'California') mydat$County = cty
    mydat <- mydat %>% 
      filter(County==cty)
    
    # Now, we'll count the total expanded households in each stratifications
    datahh.cty.all <- mydat %>% 
      mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple')) %>%
      group_by(County,HHUT,INCOM) %>% 
      summarise(hhn=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),NEXPHHWDCTYWGT,NEXPHHWDWGT)*HHVEH))
    datahh.cty.hhut <- mydat %>% 
      mutate(HHUT=ifelse(RESTY==1 | RESTY==2,'Single','Multiple'),
             INCOM='Total'
      ) %>%
      group_by(County,HHUT,INCOM) %>% 
      summarise(hhn=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),NEXPHHWDCTYWGT,NEXPHHWDWGT)*HHVEH))
    datahh.cty.incom <- mydat %>% 
      mutate(HHUT='Total',
             INCOM=INCOM
      ) %>%
      group_by(County,HHUT,INCOM) %>% 
      summarise(hhn=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),NEXPHHWDCTYWGT,NEXPHHWDWGT)*HHVEH))
    datahh.cty <- mydat %>% 
      mutate(HHUT='Total',
             INCOM='Total'
      ) %>%
      group_by(County,HHUT,INCOM) %>% 
      summarise(hhn=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),NEXPHHWDCTYWGT,NEXPHHWDWGT)*HHVEH))
    
    return(rbind(datahh.cty.all,datahh.cty.hhut,datahh.cty.incom,datahh.cty))
  })
}


datahh <- do.call(
  "rbind",
  lapply(
    c('California',sort(unique(fipsctyca$County))),
    dohhagg(hhtt)
  )
)

  
```

Now, `data` has the linked trips for each weekday driver trip.  We can simply compute the mean for
each combination.

```{r rt-table-15-3}
# take the trip aggs (appg), join the household aggs by stratification, devide totals
agg1 <- aggp %>% left_join(datahh,by=c('County','HHUT','INCOM')) %>% 
  mutate(nn=n/hhn) %>% select(-n,-hhn) %>% ungroup()

res.15 <- agg1  %>%
  spread(HHUT,nn) %>% # reorganize for table
  arrange(ifelse(County=='California','aaaaaaa',County),INCOM) %>% 
  select(County,INCOM,Single,Multiple,Total)

t <- lapply(
  c('California',sort(unique(res.15$County))),
  function(cty) {
    dat<-res.15 %>% filter(County==cty) %>%
      select(`Household Income`=INCOM,Single,Multiple,Total)
    
    return(pandoc.table.return(
      dat,
      caption=paste("TABLE 15: Weekday Driver Trips Per Vehicle (",cty,")",sep=""),
      split.table=Inf,split.cells=Inf,
      big.mark=',',
      round=1,
      #               justify=c('left','left','right','right','right'),
      style='multiline'))
  })
res.15.str <- paste(t,collapse="\n\n")
res[["res.15"]] <- list()
res[["res.15"]]$title  <- "TABLE 15: Weekday Driver Trips Per Vehicle"
res[["res.15"]]$data <- res.15
res[["res.15"]]$tabtxt <- res.15.str
```


```{r rt-table15-output,results='asis',cache=FALSE}
cat(res.15.str)
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 15a: Weekday Person and Vehicle Miles Traveled per Vehicle by County and HH Income')
```


```{r rt-table-15a}
# compute person trips per category
# Filter for weekday person trips and count the expanded total trip distance per type
data <- chts_pla %>%
  left_join(chts_per.wgt.wd,by=c('SAMPN','PERNO')) %>% # join weekday weights (and WD)
  filter(WD==1 & !is.na(TCF) & !is.na(TripDistance)) %>% # only weekdays
  group_by(SAMPN,PERNO) %>% summarise(
    n=sum(NEXPPERWDWGT*TCF*TripDistance),
    nv=sum(ifelse(MODE %in% driver.trip.modes,NEXPPERWDWGT*TCF*TripDistance,0))
    )

# next, attach the household characteristics to each trip observation
hhtt <- chts_hh %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
  left_join(fipsctyca,by=c('ICTFIP'='county_ansi')) %>% 
  select(SAMPN,INCOM,County)
hhtt$INCOM <- assign_factors(hhtt$INCOM,'hh','INCOM')

data2 <- data  %>% 
  left_join(hhtt, by=c('SAMPN'))

# Now, aggregate the expanded driver trip totals by the stratifications
aggp.all <- data2 %>% group_by(County,INCOM) %>% summarise(n=sum(n),nv=sum(nv))
aggp.cty <- data2 %>% 
  mutate(INCOM='Total') %>% 
  group_by(County,INCOM) %>% 
  summarise(n=sum(n),nv=sum(nv))
aggp <- rbind(aggp.all,aggp.cty)

# Now, we'll count the total expanded households in each stratifications
datahh.all <- hhtt %>% 
  left_join(chts_hh.wgt.wd,by=c('SAMPN'))  %>% filter(WD==1) %>%
  group_by(County,INCOM) %>% summarise(hhn=sum(NEXPHHWDWGT))
datahh.cty <- datahh.all %>% ungroup() %>% 
  mutate(INCOM='Total') %>%
  group_by(County,INCOM) %>% summarise(hhn=sum(hhn))
datahh <- rbind(datahh.all,datahh.cty)
```

Now, `data` has the linked trips for each weekday driver trip.  We can simply compute the mean for
each combination.

```{r rt-table-15a-3}
# take the trip aggs (appg), join the household aggs by stratification, devide totals
res.15a <- aggp %>% 
  left_join(datahh,by=c('County','INCOM')) %>% 
  mutate(nn=n/hhn,nnv=nv/hhn) %>% 
  select(-n,-nv,-hhn) %>% ungroup()

res.15a.str <-
  paste(
    lapply(
      c(sort(unique(res.15a$County))),
      function(cty) {
        dat <- res.15a %>% filter(County==cty) %>%
          select(`Household Income`=INCOM,`PMT/HH`=nn,`VMT/HH`=nnv)
        
        tab <- pandoc.table.return(
          dat,
          caption=paste("TABLE 15a: Person and Vehicle Miles Traveled per Household (",cty,")",sep=""),
          split.table=Inf,split.cells=Inf,
          big.mark=',',
          round=1,
          justify=c('center','right','right'),
          style='multiline')
        return(tab)
      }
    ),
    collapse="\n\n\n"
  )

res[["res.15a"]] <- list()
res[["res.15a"]]$title  <- "TABLE 15a: Person and Vehicle Miles Traveled Per Household"
res[["res.15a"]]$data <- res.15a
res[["res.15a"]]$tabtxt <- res.15a.str
```


```{r rt-table15a-output,results='asis',cache=FALSE}
cat(res.15a.str)
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 17a: Weekday Unlinked and Linked Trips Distributed by Particular Travel Mode and Group')
```


```{r rt-table-17a}
mode.groups <- data.frame( 
  ltmode=c(
    c(5,8,10),
    c(6,7,9,11,14),
    c(15,16,17,18,19,20,21,22,23,24,25,26,27),
    c(12,13),
    c(1,2,3,4,28,29)
    ),
  MODE.GROUP=c(
    rep('Vehicle Driver',3),
    rep('Vehicle Passenger',5),
    rep('Local Public Transit',13),
    rep('Intercity Public Transportation',2),
    rep('Miscelleneous Modes',6)
    ),
  stringsAsFactors=FALSE
  )

# unlinked trips
tab.ul <- chts_pla %>% 
  left_join(chts_per.wgt.wd,by=c('SAMPN','PERNO')) %>%
  filter(WD==1) %>%
  filter(!is.na(MODE)) %>%
  left_join(mode.groups %>% select(MODE.GROUP=MODE.GROUP,MODE=ltmode),by=c('MODE')) %>% 
  mutate(NEXPTCFPERWDWGT=NEXPPERWDWGT*TCF) %>%
  group_by(MODE.GROUP,MODE) %>% 
  summarise(num=sum(NEXPTCFPERWDWGT,na.rm=TRUE))
tab.ul$MODE <- assign_factors(tab.ul$MODE,'place','MODE',maxlab=20)
tots.ul <- tab.ul %>% ungroup() %>% group_by(MODE.GROUP) %>% summarise(MODE="TOTAL",tnum=sum(num))
gtots.ul <-  tots.ul %>% filter(MODE=='TOTAL') %>% 
  summarise(MODE.GROUP='ALL GROUPS',
            MODE='TOTAL',
            gtnum=sum(tnum))
ftab.ul <- rbind(tab.ul,tots.ul %>% select(MODE.GROUP,MODE,num=tnum)) %>% 
  arrange(MODE.GROUP,num) %>%
  left_join(tots.ul %>% select(-MODE),by=c('MODE.GROUP')) %>%
  rbind(gtots.ul %>% transmute(MODE.GROUP=MODE.GROUP,MODE=MODE,num=gtnum,tnum=gtnum))

fftab.ul <- ftab.ul %>%
  ungroup() %>%
  transmute(
    MODE.GROUP=MODE.GROUP,
    MODE=as.character(MODE),
    `Number of Unlinked Trips`=round(num,0),
    `Percent of Total Unlinked`=round(num/gtots.ul$gtnum[1]*100,1),
    SORT.ORDER=ifelse(MODE.GROUP=='ALL GROUPS',
                      -Inf,
                      ifelse(MODE.GROUP=='Miscelleneous Modes',
                             -(tnum*100000000-ifelse(MODE=='TOTAL',-num,num)),
                             tnum*100000000+ifelse(MODE=='TOTAL',-num,num)))
    )

# linked trips
tab <- lt.wd.trips %>% 
  left_join(mode.groups,by=c('ltmode')) %>% group_by(MODE.GROUP,ltmode) %>% 
  filter(!is.na(ltmode)) %>%
  summarise(num=sum(NEXPTCFPERWDWGT,na.rm=TRUE))
#  summarise(num=n())
tab$ltmode <- assign_factors(tab$ltmode,'place','MODE',maxlab = 20)
tots <- tab %>% ungroup() %>% group_by(MODE.GROUP) %>% summarise(ltmode="TOTAL",tnum=sum(num))
gtots <-  tots %>% filter(ltmode=='TOTAL') %>% 
  summarise(MODE.GROUP='ALL GROUPS',
            ltmode='TOTAL',
            gtnum=sum(tnum))
ftab <- rbind(tab,tots %>% select(MODE.GROUP,ltmode,num=tnum)) %>% arrange(MODE.GROUP,num) %>%
  left_join(tots %>% select(-ltmode),by=c('MODE.GROUP')) %>%
  rbind(gtots %>% transmute(MODE.GROUP=MODE.GROUP,ltmode=ltmode,num=gtnum,tnum=gtnum))


fftab <- ftab %>%
  ungroup() %>%
  transmute(
    MODE.GROUP=MODE.GROUP,
    MODE=as.character(ltmode),
    `Number of Linked Trips`=round(num,0),
    `Percent of Total Linked`=round(num/gtots$gtnum[1]*100,1))
 
fftab.all <- fftab.ul %>% left_join(fftab,by=c('MODE.GROUP','MODE')) %>%
  transmute(
    `TRAVEL MODE GROUP`=MODE.GROUP,
    MODE=MODE,
    `Number of Unlinked Trips`=`Number of Unlinked Trips`,
    `Percent of Total Unlinked`=`Percent of Total Unlinked`,
    `Number of Linked Trips`=`Number of Linked Trips`,
    `Percent of Total Linked`=`Percent of Total Linked`,
    SORT.ORDER=SORT.ORDER
    ) %>%
  arrange(desc(SORT.ORDER)) %>%
  mutate(`TRAVEL MODE GROUP`=ifelse(is.na(lag(MODE)) | grepl('TOTAL',lag(MODE)), 
                                    `TRAVEL MODE GROUP`, "&nbsp;")) %>%
  select(-SORT.ORDER)


res.17a.st <- fftab.all

res.17a.st.str <- pandoc.table.return(res.17a.st,
             caption=paste("TABLE 17a: Weekday Linked and Unlinked Trips Distributed by Particular Travel Mode and Group (California)",sep=""),
             split.table=Inf,split.cells=Inf,
             justify=c('left','left','right','right','right','right'),
             style='multiline',
             round=Inf
             #,emphasize.strong.rows=which(fftab.all$MODE=='TOTAL',arr.ind=TRUE)
             )
```
```{r rt-table-17a-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.17a.st.str)
```

Now, by county.

```{r rt-table-17a-2}
mode.groups <- data.frame( 
  ltmode=c(
    c(5,8,10),
    c(6,7,9,11,14),
    c(15,16,17,18,19,20,21,22,23,24,25,26,27),
    c(12,13),
    c(1,2,3,4,28,29)
    ),
  MODE.GROUP=c(
    rep('Vehicle Driver',3),
    rep('Vehicle Passenger',5),
    rep('Local Public Transit',13),
    rep('Intercity Public Transportation',2),
    rep('Miscelleneous Modes',6)
    ),
  stringsAsFactors=FALSE
  )

lt.wd.cty <- chts_per.wgt.wd.cty %>% 
  filter(grepl("\\.1$",GROUP)) %>% # grab weekday travelers
  select(SAMPN,PERNO,GROUP,NEXPPERWDCTYWGT,NPERWDCTYWGT) %>%  # select what we want
  left_join(lt.clean,by=c('SAMPN','PERNO')) %>%  # join on the linked trips
  mutate(NEXPTCFPERWDCTYWGT=NEXPPERWDCTYWGT*ltTCF)  # compute the TCF weights

tab.ul.raw <-chts_pla %>% 
    arrange(SAMPN,PERNO,PLANO) %>%
    mutate(oCTFIP=lag(CTFIP)) %>%
    left_join(chts_per.wgt.wd.cty,by=c('SAMPN','PERNO')) %>%
    filter(!is.na(MODE))
  
tab.raw <- lt.wd.cty %>% 
    filter(!is.na(ltmode)) %>%
    left_join(mode.groups,by=c('ltmode')) %>% group_by(MODE.GROUP,ltmode) %>% 
    left_join(chts_pla %>% select(SAMPN,PERNO,PLANO,oCTFIP=CTFIP),
              by=c("SAMPN"="SAMPN","PERNO"="PERNO",
                   "oplano"="PLANO")) %>%
    left_join(chts_pla %>% select(SAMPN,PERNO,PLANO,dCTFIP=CTFIP),
              by=c("SAMPN"="SAMPN","PERNO"="PERNO",
                   "dplano"="PLANO"))

res.17a.cty.str <- 
  paste(
    lapply(
      sort(unique(fipsctyca$county_ansi)),
      function(icty) {
        cty <- fipsctyca %>% filter(county_ansi==icty)
        cty <- cty$County
        # unlinked trips
        
        tab.ul <- 
          tab.ul.raw %>%
          filter(grepl("\\.1$",GROUP) & (as.integer(CTFIP)==icty | as.integer(oCTFIP)==icty)) %>%
          left_join(mode.groups %>% select(MODE.GROUP=MODE.GROUP,MODE=ltmode),
                    by=c('MODE')) %>% 
          mutate(NEXPTCFPERWDCTYWGT=NEXPPERWDCTYWGT*TCF) %>%
          group_by(MODE.GROUP,MODE) %>% 
          summarise(num=sum(NEXPTCFPERWDCTYWGT,na.rm=TRUE))
        tab.ul$MODE <- assign_factors(tab.ul$MODE,'place','MODE',maxlab=20)
        tots.ul <- tab.ul %>% ungroup() %>% group_by(MODE.GROUP) %>% summarise(MODE="TOTAL",tnum=sum(num))
        gtots.ul <-  tots.ul %>% filter(MODE=='TOTAL') %>% 
          summarise(MODE.GROUP='ALL GROUPS',
                    MODE='TOTAL',
                    gtnum=sum(tnum))
        ftab.ul <- rbind(tab.ul,tots.ul %>% select(MODE.GROUP,MODE,num=tnum)) %>% 
          arrange(MODE.GROUP,num) %>%
          left_join(tots.ul %>% select(-MODE),by=c('MODE.GROUP')) %>%
          rbind(gtots.ul %>% transmute(MODE.GROUP=MODE.GROUP,MODE=MODE,num=gtnum,tnum=gtnum))
        
        fftab.ul <- ftab.ul %>%
          ungroup() %>%
          transmute(
            MODE.GROUP=MODE.GROUP,
            MODE=as.character(MODE),
            `Number of Unlinked Trips`=num,
            `Percent of Total Unlinked`=round(num/gtots.ul$gtnum[1]*100,1),
            SORT.ORDER=ifelse(MODE.GROUP=='ALL GROUPS',
                              -Inf,
                              ifelse(MODE.GROUP=='Miscelleneous Modes',
                                     -(tnum*100000000-ifelse(MODE=='TOTAL',-num,num)),
                                     tnum*100000000+ifelse(MODE=='TOTAL',-num,num)))
          )
        
        # linked trips
        tab <- 
          tab.raw %>%
          filter(as.integer(oCTFIP)==icty | as.integer(dCTFIP)==icty) %>%
          summarise(num=sum(NEXPTCFPERWDCTYWGT,na.rm=TRUE))
        #  summarise(num=n())
        tab$ltmode <- assign_factors(tab$ltmode,'place','MODE',maxlab = 20)
        tots <- tab %>% ungroup() %>% group_by(MODE.GROUP) %>% summarise(ltmode="TOTAL",tnum=sum(num))
        gtots <-  tots %>% filter(ltmode=='TOTAL') %>% 
          summarise(MODE.GROUP='ALL GROUPS',
                    ltmode='TOTAL',
                    gtnum=sum(tnum))
        ftab <- rbind(tab,tots %>% select(MODE.GROUP,ltmode,num=tnum)) %>% arrange(MODE.GROUP,num) %>%
          left_join(tots %>% select(-ltmode),by=c('MODE.GROUP')) %>%
          rbind(gtots %>% transmute(MODE.GROUP=MODE.GROUP,ltmode=ltmode,num=gtnum,tnum=gtnum))
        
        
        fftab <- ftab %>%
          ungroup() %>%
          transmute(
            MODE.GROUP=MODE.GROUP,
            MODE=as.character(ltmode),
            `Number of Linked Trips`=round(num,0),
            `Percent of Total Linked`=round(num/gtots$gtnum[1]*100,1))
        
        fftab.all <- fftab.ul %>% left_join(fftab,by=c('MODE.GROUP','MODE')) %>%
          transmute(
            `TRAVEL MODE GROUP`=MODE.GROUP,
            MODE=MODE,
            `Number of Unlinked Trips`=`Number of Unlinked Trips`,
            `Percent of Total Unlinked`=`Percent of Total Unlinked`,
            `Number of Linked Trips`=`Number of Linked Trips`,
            `Percent of Total Linked`=`Percent of Total Linked`,
            SORT.ORDER=SORT.ORDER
          ) %>%
          arrange(desc(SORT.ORDER)) %>%
          mutate(`TRAVEL MODE GROUP`=ifelse(is.na(lag(MODE)) | grepl('TOTAL',lag(MODE)), 
                                            `TRAVEL MODE GROUP`, "&nbsp;")) %>%
          select(-SORT.ORDER)
        
        return(
          pandoc.table.return(fftab.all,
                              caption=paste("TABLE 17a: Weekday Linked and Unlinked Trips Distributed by Particular Travel Mode and Group (",cty,")",sep=""),
                              split.table=Inf,split.cells=Inf,
                              justify=c('left','left','right','right','right','right'),
                              style='multiline',
                              round=Inf
                              #,emphasize.strong.rows=which(fftab.all$MODE=='TOTAL',arr.ind=TRUE
          )
        )
      }),
    collapse="\n\n\n"
  )
```

```{r rt-t17a-cty-results,echo=FALSE,results='asis',cache=FALSE}
cat(res.17a.cty.str)
res[["res.17a"]] <- list()
res[["res.17a"]]$title  <- "TABLE 17a: Weekday Linked and Unlinked Trips Distributed by Particular Travel Mode and Group"
res[["res.17a"]]$data.1 <- res.17a.st
res[["res.17a"]]$data.2 <- NA
res[["res.17a"]]$tabtxt <- paste(res.17a.st.str,res.17a.cty.str,sep="\n\n\n")
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##',"Table 17B and 17C: Weekday Commuters' Directional Travel Mode Split")
```

```{r rt-table-17bc}
mode.groups <- data.frame( 
  ltmode=c(
    c(5,8,10),
    c(6,7,9,11,14),
    c(15,16,17,18,19,20,21,22,23,24,25,26,27),
    c(12,13),
    c(1),
    c(2),
    c(3,4,28,29)
    ),
  MODE.GROUP=c(
    rep('Vehicle Driver',3),
    rep('Vehicle Passenger',5),
    rep('Local Public Transit',13),
    rep('Intercity Public Transportation',2),
    rep('Walk',1),
    rep('Bike',1),
    rep('Miscelleneous Modes',4)
    ),
  order = c(
    rep(1,3),
    rep(2,5),
    rep(3,13),
    rep(4,2),
    rep(5,1),
    rep(6,1),
    rep(7,4)
  ),
  stringsAsFactors=FALSE
  )

gentab <- function(data) {
  tab <- data %>%  
    left_join(mode.groups,by=c('ltmode')) %>% group_by(MODE.GROUP,ltmode) %>% 
    summarise(num=sum(NEXPTCFPERWDWGT,na.rm=TRUE),order=min(order)) %>% 
    ungroup() %>%
    arrange(order,MODE.GROUP)
  
  tots <- tab %>% ungroup() %>% group_by(MODE.GROUP) %>% 
    summarise(tnum=sum(num),order=min(order)) %>% ungroup() %>%
    arrange(order,MODE.GROUP)
  gtots <-  tots %>%  
    summarise(MODE.GROUP='Total',
              gtnum=sum(tnum),order=Inf)
  ftab <- tots %>% select(MODE.GROUP,num=tnum,order) %>%
    rbind(gtots %>% transmute(MODE.GROUP=MODE.GROUP,num=gtnum,order=order))
  ftab <- ftab %>% ungroup() %>%
    mutate(pct = round(num/gtots$gtnum[1]*100,1))
  return(ftab)
}

# linked trips
All.lt <- lt.wd.trips %>%
  filter(!is.na(ltmode) & TripType=='HW') %>%
  left_join(chts_hh %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
              left_join(fipsctyca,by=c('ICTFIP'='county_ansi')), 
            by=c('SAMPN'))


Am.lt <- All.lt %>% filter(DEP_HR %in% c(7,8))

res.17bc.str <- 
  paste(
    lapply(
      c("California",sort(unique(All.lt$County))),
      function(cty) {
        
        all.lt <- All.lt
        am.lt <- Am.lt
        if(cty != "California") {
          all.lt <- All.lt %>% filter(County==cty)
          am.lt  <- Am.lt %>% filter(County==cty)
        }
        
        fftab.alldayt <- gentab(all.lt) %>% mutate(period='All.Day')
        fftab.allday <- fftab.alldayt %>% 
          select(MODE.GROUP,order,num,period) %>% 
          spread(period,num) %>% 
          select(MODE.GROUP,All.Day.num=All.Day,order) %>% 
          left_join(fftab.alldayt %>% 
                      select(MODE.GROUP,pct,period) %>% 
                      spread(period,pct) %>% 
                      select(MODE.GROUP,All.Day.pct=All.Day),
                    by=c('MODE.GROUP')) %>% 
          arrange(order) 
        
        fftab.amt <- gentab(am.lt) %>% mutate(period='AM')
        fftab.am <- fftab.amt %>% 
          select(MODE.GROUP,order,num,period) %>% 
          spread(period,num) %>% 
          select(MODE.GROUP,AM.num=AM,order) %>% 
          left_join(fftab.amt %>% 
                      select(MODE.GROUP,pct,period) %>% 
                      spread(period,pct) %>% 
                      select(MODE.GROUP,AM.pct=AM),
                    by=c('MODE.GROUP')) %>% 
          arrange(order) %>% select(-order) 
        
        fftab.all <- merge(fftab.allday,fftab.am,by=c('MODE.GROUP')) %>%
          arrange(order) %>%
          transmute(`Travel Mode`=MODE.GROUP,
                 `All Home-to-Work Trips`=round(All.Day.num,0),
                 `All Home-to-Work Trips (%)`=All.Day.pct,
                 `7:00-9:00am Home-to-Work Commute Trips`=round(AM.num,0),
                 `7:00-9:00am Home-to-Work Commute Trips (%)`=AM.pct,
                 order=order
          ) %>%
          mutate(County=cty)
        if ( !exists("res.17bc") ) {
          res.17bc <- fftab.all
        } else {
          res.17bc <- rbind(res.17bc,fftab.all)
        }
        
        return(
          pandoc.table.return(
            fftab.all %>% arrange(order) %>% select(-order,-County),
            caption=paste("TABLES 17b and 17c: Weekday Commuters' Directional Travel Mode by County (",cty,")",sep=""),
            split.table=Inf,split.cells=Inf,
            justify=c('left','right','right','right','right'),
            style='multiline',
            round=Inf
            #,emphasize.strong.rows=which(fftab.all$MODE=='TOTAL',arr.ind=TRUE
          )
        )
      }),
    collapse="\n\n\n"
  )
```
```{r rt-table-17bc-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.17bc.str)
res[["res.17bc"]] <- list()
res[["res.17bc"]]$title  <- "TABLES 17b and 17c: Weekday Commuters' Directional Travel Mode by County"
res[["res.17bc"]]$data <- NA #res.17bc
res[["res.17bc"]]$tabtxt <- res.17bc.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 22: Age of Vehicle in Use on Travel Day by County and Vehicle Type')
```


```{r rt-table-22}
Vehdat <- chts_veh %>%
  left_join(chts_hh %>% mutate(ICTFIP=as.integer(CTFIP)%%1000) %>%
              select(-HHWGT,-EXPHHWGT) %>%
              left_join(fipsctyca,by=c('ICTFIP'='county_ansi')), 
            by=c('SAMPN')) %>%
  left_join(chts_hh.wgt.wd.cty,by=c("SAMPN")) %>%
  left_join(chts_hh.wgt.wd,by=c("SAMPN")) %>%
  mutate(WD=ifelse(DOW<6,1,2)) %>%
  filter(WD==1)

res.22.str <- 
  paste(
    lapply(
      c("California",sort(unique(Vehdat$County))),
      function(cty) {
        
        vehdat <- Vehdat
        if(cty != "California") {
          vehdat <- Vehdat %>% filter(County==cty)
        }
        
        usedveh <- vehdat %>% filter(CNTV==1)
        
        res <- usedveh %>% 
          mutate(ystr=as.character(YEAR)) %>%
          mutate(AGE=ifelse(ystr %in% c("9998","9999"),
                            "Unknown",
                            ifelse(as.integer(ystr)<1992,">21",
                                   ifelse(as.integer(ystr)==2013,'<1',2013-as.integer(ystr)))),
                 MODEL.YEAR=ifelse(ystr %in% c("9998","9999"),
                                   "Not Known",
                                   ifelse(as.integer(ystr)<1992,"1991 or Earlier",YEAR))
          ) %>% 
          group_by(AGE,MODEL.YEAR) %>%
          summarise(n=sum(ifelse(grepl(paste("^",cty,"$",sep=""),County),NEXPHHWDCTYWGT,NEXPHHWDWGT)),
                    YEAR=min(as.integer(YEAR))) %>% 
          ungroup() %>%
          mutate(YEAR=ifelse(YEAR>9000,-YEAR,YEAR))
        rest <- res %>% ungroup() %>% mutate(YEAR=as.integer(YEAR)) %>%
          arrange(desc(YEAR)) %>% select(-YEAR)
        rest.2 <- rest %>% mutate(pct=n/sum(res$n)*100,cumpct=cumsum(n)/sum(res$n)*100)
        res.22 <- rest.2 %>% transmute(`Model Year`=MODEL.YEAR,
                                       `Age of Vehicle`=AGE,
                                       `Num of Veh in Use`=round(n,0),
                                       `Percent of Vehicles`=round(pct,1),
                                       `Cumulative Percent`=round(cumpct,1))
        res.22 <- rbind(res.22, rest.2 %>% summarise(`Model Year`=NA,
                                                     `Age of Vehicle`='TOTAL',
                                                     `Num of Veh in Use`=round(sum(rest.2$n),0),
                                                     `Percent of Vehicles`=NA,
                                                     `Cumulative Percent`=NA))
        return(
          pandoc.table.return(
            res.22,
            caption=paste("TABLE 22: Vehicles in Use on Average Weekday Distributed by Age of Vehicle by County (",cty,")",sep=""),
            split.table=Inf,split.cells=Inf,
            justify=c('center','center','right','right','right'),
            style='multiline',
            round=Inf,
            big.mark = ',',
            missing='&nbsp;'
            ,emphasize.strong.rows=which(res.22$`Age of Vehicle`=='TOTAL',arr.ind=TRUE)
          ))
      }),
    collapse="\n\n\n"
  )
```
```{r rt-table-22-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.22.str) 
res[["res.22"]] <- list()
res[["res.22"]]$title  <- "TABLE 22: Vehicles in Use on Average Weekday Distributed by Age of Vehicle and by County"
res[["res.22"]]$data <- NA
res[["res.22"]]$tabtxt <- res.22.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 22a: Vehicle Trips, Person Trips by County by Mode and Purpose')
```


How to define VT?  By definition, Transit trips will have zero VMT, so having both VMT and mode split doesn't make sense to me.


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 50: Mode Share for Short Trips by County')
```


Also asked for cities, but samples sizes will be too small for most.

```{r rt-t50}
dat <- chts_pla %>%  
  filter(PLANO!=1) %>%  # remove start of day
  filter(is.na(TripDistanceFlag) & TripDistance < 3) %>%  # weighting issue!
  mutate(oCTFIP=as.integer(lag(CTFIP))) %>%  # origin CTFIP
  left_join(fipsctyca %>% select(county_ansi,oCounty=County),
            by=c('oCTFIP'='county_ansi')) %>%
  filter(!is.na(oCounty)) %>%
  mutate(DIST=ifelse(TripDistance<1,'< 1 mile','1 to 3 miles'),
         Mode=ifelse(MODE==1,'Walk',
                     ifelse(MODE==2,'Bike',
                            ifelse(MODE %in% public.transit.trip.modes, 'Transit',
                                   'All Others'))))
t <- dat %>% 
  group_by(oCounty,DIST,Mode) %>% 
  summarise(n=sum(EXPTCFPERWGT,na.rm=TRUE))

tt <- t %>% ungroup() %>% 
  mutate(Mode='Total') %>% 
  group_by(oCounty,DIST,Mode) %>% summarise(n=sum(n))
t2 <- t %>% left_join(tt %>% select(oCounty,DIST,nt=n),by=c('oCounty','DIST')) %>%
  mutate(pct=round(100*n/nt,1))
res.50 <- t2 %>% select(oCounty,Mode,DIST,pct) %>% spread(DIST,pct) %>%
  arrange(oCounty,ifelse(Mode=='All Others','ZZZZ',Mode))

res.50.str <-
  paste(
    lapply(
      sort(unique(fipsctyca$County)),
      function(cty) {
        return(pandoc.table.return(
          res.50 %>% filter(oCounty==cty) %>%
            select(-oCounty),
          caption=paste("TABLE 50: Mode Share for Short Distance Trips by County (",cty,")",sep=""),
          split.table=Inf,split.cells=Inf,
          justify=c('center','right','right'),
          style='multiline',
          round=Inf,
          big.mark = ','
        ))
      }),
    collapse="\n\n"
  )
```
```{r rt-table-50-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.50.str)
res[["res.50"]] <- list()
res[["res.50"]]$title  <- "TABLE 50: Mode Share for Short Distance Trips by county"
res[["res.50"]]$data <- res.50
res[["res.50"]]$tabtxt <- res.50.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##','TABLE 51: Mode Share for Millennials Versus Older Age Groups')
```



```{r rt-table-51}
# following pew: http://www.pewresearch.org/fact-tank/2015/01/16/this-year-millennials-will-overtake-baby-boomers/
millenials <- 18:35-(2015-2012)

dat <- chts_pla %>%  
  left_join(chts_per,by=c('SAMPN','PERNO')) %>%
  filter(AGE>14) %>%
  filter(PLANO!=1) %>%  # remove start of day
  mutate(Mode=ifelse(
    MODE %in% driver.trip.modes, 'Driver',
    ifelse(
      MODE %in% c(6), 'Passenger',
      ifelse(
        MODE %in% public.transit.trip.modes, 'Transit',
        ifelse(
          MODE==1,'Walk',
          ifelse(
            MODE==2, 'Bike',
            'All Others'
          )
        )
      )
    )
  ),
  Generation=ifelse(AGE %in% millenials,
                    'Millenials (15-32)',
                    'Older Generations'))

t <- dat %>% group_by(Generation,Mode) %>% summarise(n=sum(EXPTCFPERWGT,na.rm=TRUE))
tt <- dat %>% mutate(Mode='All Modes') %>% 
  group_by(Generation,Mode) %>% 
  summarise(n=sum(EXPTCFPERWGT,na.rm=TRUE))
t2 <- rbind(t) %>% ungroup()
res.51 <- t2 %>% left_join(tt %>% select(Generation,nt=n), by=c('Generation')) %>%
  transmute(Generation=Generation,Mode=Mode,n=n,pct=round(100*n/nt,1)) %>%
  select(Generation,Mode,pct) %>%
  spread(Generation,pct) %>%
  arrange(ifelse(Mode=='All Modes',-999,'A'),
          desc(`Millenials (15-32)`))

res.51.str <-
  pandoc.table.return(
    res.51,
    caption=paste(
      "TABLE 51: Driver trips, bike, walk and transit for millennial versus older age groups. ",
      sep=""),
    split.table=Inf,split.cells=Inf,
    justify=c('center','right','right'),
    style='multiline',
    round=Inf,
    big.mark = ','
  )
```
```{r rt-table-51-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.51.str)
res[["res.51"]] <- list()
res[["res.51"]]$title  <- "TABLE 51: Driver trips, bike, walk and transit for millennial versus older age groups"
res[["res.51"]]$data <- res.51
res[["res.51"]]$tabtxt <- res.51.str

```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##',"TABLE 52: Statewide Commute trips by Mode and Distance Ranges")
```


```{r rt-table-52}
 #0.00-0.50
#0.50-1.00
#1.00- 2.00
#2.00 – 5.00
#5.00 – 10.00
#10.00+
dat <- lt.clean %>%  
  filter(!is.na(tripdist) & !is.na(ltmode)) %>%
  filter(TripType=='HW') %>%
  left_join(chts_per,by=c('SAMPN','PERNO')) %>%
  mutate(
    Mode=ifelse(
      ltmode %in% driver.trip.modes, 'Driver',
      ifelse(
        ltmode %in% c(6), 'Passenger',
        ifelse(
          ltmode %in% public.transit.trip.modes, 'Transit',
          ifelse(
            ltmode %in% c(1),'Walk',
            ifelse(
              ltmode %in% c(2), 'Bike',
              'All Others'
            )
          )
        )
      )
    )) %>% 
  mutate(
    NEXPTCFPERWGT=EXPPERWGT*ltTCF,
    Distance=ifelse(
      tripdist < 0.5, '0.0 - 0.5mi',
      ifelse(
        tripdist < 1.0, '0.5 - 1.0mi',
        ifelse(
          tripdist < 2.0, '1.0 - 2.0mi',
          ifelse(
            tripdist < 5.0, '2.0 - 5.0mi',
            ifelse(
              tripdist < 10.0, '5.0 - 10.0mi',
              '10.0mi or greater'
            )
          )
        )
      )
    )
  )
```
```{r rt-t52.1}
agg <- dat %>% group_by(Distance,Mode) %>% summarise(n=sum(NEXPTCFPERWGT))
aggt.dist <- dat %>% group_by(Distance) %>% summarise(n=sum(NEXPTCFPERWGT)) %>%
  mutate(Mode='All Modes')
agg.all <- rbind(agg,aggt.dist) %>%
  left_join(aggt.dist %>% select(Distance,nt=n),by=c('Distance')) %>%
  ungroup() %>%
  transmute(Distance=Distance,Mode=Mode,Trips=round(n,0),Pct=round(n/nt*100,1)) %>%
  as.data.frame() %>%
  select(-Trips) %>%
  spread(Mode,Pct) %>%
  arrange(as.double(gsub("^(\\d+\\.\\d+).*?$","\\1",Distance)))  %>%
  select(Distance,Driver,Passenger,Transit,Bike,Walk,`All Others`,`All Modes`)
res.52 <- agg.all
res.52.str <-
  pandoc.table.return(
    agg.all,
    caption=paste(
      "TABLE 52: Statewide Commute trips (HW) by Mode (Walk, Bike, Drive/Passenger, Transit) and other by Mode and Distance ranges",
      sep=""),
    split.table=Inf,split.cells=Inf,
    justify=rep('right',8),
    style='multiline',
    round=Inf,
    big.mark = ','
  )
```
```{r rt-table-52-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.52.str)
res[["res.52"]] <- list()
res[["res.52"]]$title  <- "TABLE 52: Statewide Commute trips (HW) by Mode (Walk, Bike, Drive/Passenger, Transit) and other by Mode and Distance ranges"
res[["res.52"]]$data <- res.52
res[["res.52"]]$tabtxt <- res.52.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC('##',"TABLE 53: Statewide School Trips by Mode and Distance Ranges")
```


```{r rt-t53}
# get all linked trips with a school activity at the destination

lt.dat <- chts_act %>% 
  select(SAMPN,PERNO,PLANO,ACTNO,APURP) %>% 
  filter(APURP==17) %>% 
  left_join(chts_lu_lt,by=c('SAMPN','PERNO','PLANO','ACTNO')) %>%
  group_by(LTNO) %>% 
  summarise(n=n()) %>% 
  select(LTNO) %>%
  left_join(lt.clean,by=c('LTNO'))

dat <- lt.dat %>%  
  filter(!is.na(tripdist) & !is.na(ltmode)) %>%
  left_join(chts_per,by=c('SAMPN','PERNO')) %>%
  mutate(
    Mode=ifelse(
      ltmode %in% driver.trip.modes, 'Driver',
      ifelse(
        ltmode %in% c(6), 'Passenger',
        ifelse(
          ltmode %in% public.transit.trip.modes, 'Transit',
          ifelse(
            ltmode %in% c(1),'Walk',
            ifelse(
              ltmode %in% c(2), 'Bike',
              'All Others'
            )
          )
        )
      )
    )) %>% 
  mutate(
    NEXPTCFPERWGT=EXPPERWGT*ltTCF,
    Distance=ifelse(
      tripdist < 0.25, '0.0 - 0.25mi',
      ifelse(
        tripdist < 0.5, '0.25 - 0.5mi',
        ifelse(
          tripdist < 1.0, '0.50 - 1.0mi',
          ifelse(
            tripdist < 2.0, '1.0 - 2.0mi',
              '2.0mi or greater'
            )
          )
        )
      )
    )
```
```{r rt-t53.1}
agg <- dat %>% group_by(Distance,Mode) %>% summarise(n=sum(NEXPTCFPERWGT,na.rm=TRUE))
aggt.dist <- dat %>% group_by(Distance) %>% summarise(n=sum(NEXPTCFPERWGT,na.rm=TRUE)) %>%
  mutate(Mode='All Modes')
agg.all <- rbind(agg,aggt.dist) %>%
  left_join(aggt.dist %>% select(Distance,nt=n),by=c('Distance')) %>%
  ungroup() %>%
  transmute(Distance=Distance,Mode=Mode,Trips=round(n,0),Pct=round(n/nt*100,1)) %>%
  as.data.frame() %>%
  select(-Trips) %>%
  spread(Mode,Pct) %>%
  arrange(as.double(gsub("^(\\d+\\.\\d+).*?$","\\1",Distance)))  %>%
  select(Distance,Driver,Passenger,Transit,Bike,Walk,`All Others`,`All Modes`)
res.53 <- agg.all
res.53.str <- 
  pandoc.table.return(
    agg.all,
    caption=paste(
      "TABLE 53: Statewide School Trips by Mode (Walk, Bike, Drive/Passenger, Transit) and other by Mode and Distance ranges",
      sep=""),
    split.table=Inf,split.cells=Inf,
    justify=rep('right',8),
    style='multiline',
    round=Inf,
    big.mark = ','
  )
```
```{r rt-table-53-results,results='asis',echo=FALSE,cache=FALSE}
cat(res.53.str)
res[["res.53"]] <- list()
res[["res.53"]]$title  <- "TABLE 53: Statewide School Trips (HW) by Mode (Walk, Bike, Drive/Passenger, Transit) and other by Mode and Distance ranges"
res[["res.53"]]$data <- res.53
res[["res.53"]]$tabtxt <- res.53.str
```


```{r results='asis',echo=FALSE,cache=FALSE}
############################################################ NESTABLE SECTION
SEC("#","Complete Tables")
if ( rmarkdown::metadata$documentation == "true" ) 
  lev <- lev+1
```
\fi

```{r rt-dump-all,echo=FALSE,results='asis',cache=FALSE}
cat(
  paste(
    lapply(
      names(res),
      function(k) {
        return(paste(paste("\n\n",SEC('##',res[[k]]$title,as.string=TRUE),"\n\n",res[[k]]$tabtxt)))
      }
    ),
    collapse="\n\n\\newpage\n\n"
  )
)
```
